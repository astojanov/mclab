\subsection*{Profiling}
% intro
 profiling
  \begin{itemize}
  \item extra pointcuts allow very detailed view of whats going on
  \item all the context information provides even more info
       at the same time
   \item scientific programming is basically matrix computations
   \item performance is of paramount importance
    \item also, knowing all sorts of other properties of your programs helps
    \item --> it's a domain where you want to know exactly what's going on in your program
  \end{itemize}
% flops 1
\begin{frame}{Profiling I - flops}
  \begin{itemize}
  \item in scientific/numerical computing, computational complexity is
  counted in flops
  \item knowing how many flops are made is useful
  \item we can intercept all calls to operations and accumulate
  estimates for flops
  \item (example for estimating flops of mul?) ... example code?
  \item this could be done with just plain Matlab
  \item aspect matlab allows us to collect all this functionatliay
  (concern?) into one single aspect
  \end{itemize}
\end{frame}

% flops 2
\begin{frame}{Profiling II - flops extended}
  \begin{itemize}
  \item supposse now we want to know where the flops occur, with
  enclosing info like in a profiler
  \item example
  \item now we don't only intercept functions, but also function calls
  \item we keep track of the flops in a stack
  \item we need context information
  \item in plain matlab, this is not possible without extensively
  modifying the original code
  \end{itemize}
\end{frame}

% flops 3
\begin{frame}{Profiling III - interval arithmetic}
  \begin{itemize}
  \item lets go deeper into acally changing the original program
  \item supposse we want upper ad lower bounds on numerical errors
  (precision)
  \item we can override all variables to be a structure including the
  original value and the new annotated information
  \item diagram (var) --> structure: value, some tag, annotated info
  ---- should this actually be a class???
  \item 
  \end{itemize}
\end{frame}


\subsection*{Extending Functionality}

 extending functionality
\begin{itemize}
\item we have an extensible toolkit (McLab)
\item we can use aspects for rapid prototyping of new functionality
\item we can use aspects for writing libraries
\end{itemize}

\begin{frame}{Extending Functionality I}
case 1)
\begin{itemize}
\item add some functions
\item really simple, could be done with just dumping some .m files in the
        same dir
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Extending Functionality II}
 case 2)
\begin{itemize}
\item
      consier new sntax addition
\begin{Verbatim}[commandchars=@\[\]]
      for [x,i] = Z
\end{Verbatim}
      ...
      end
\item where x is the iteration variable, and i is the iteration count
\item more complicated - functions expose context information
\item code(?)
\end{itemize}
\end{frame}




\begin{frame}[fragile]{Extending Functionality III}
case 3)
\begin{itemize}
\item unit benchmark
\item consider new addition of units
\end{itemize}
\begin{lstlisting}[language=Matlab]
bmi = 180*lb/(5*feet + 8*inches)^2
t = AU/c
\end{lstlisting}
\begin{itemize}
 \item we have some functions, but they affect all the data types.
 \item we have to (override) annotate all data
 \item we need to override loops as well
\end{itemize}
\begin{lstlisting}
aspect unit
properties
units = struct(...
  'm',  [1, 0, 0, 0, 0, 0, 0],...
  'Kg', [0, 1, 0, 0, 0, 0, 0],...
  's',  [0, 0, 1, 0, 0, 0, 0],...
...
  'J',  [2, 1,-2, 0, 0, 0, 0],...
  'N',  [1, 1,-2, 0, 0, 0, 0]);
end

patterns
allCalls : call(*());
...
end

acalls : around allCalls : (name)
if (isfield(this.units,name))
...
end
\end{lstlisting}

\end{frame}

