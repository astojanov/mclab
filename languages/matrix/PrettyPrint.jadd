/*
 *  Adapted for Natlab project 
 *  from PrettyPrint.jadd of JastAdd Extensible Java Compiler 
 *  (http://jastadd.org) created by Torbjorn Ekman.
 *
 *  Modify History:
 *  - 2008.05.27: Expr, Matrix ,.. classes
 */
import java.util.*;

aspect PrettyPrint {
	
  // For getStructureString()
  
  public String ASTNode.getStructureString() {
    StringBuffer s = new StringBuffer();
    s.append(dumpStringOnly() + "\n");
    return s.toString();
  }

  syn String ASTNode.dumpStringOnly() = toString() ;
  eq Literal.dumpStringOnly() = getLITERAL() ;
  eq ParseName.dumpStringOnly() = getID() ;
  eq MethodAccess.dumpStringOnly() = getID() ;
  eq MatrixAccess.dumpStringOnly() = getID() ;

  // Helper for indentation  
  protected static int ASTNode.indent = 0;
  
  public static String ASTNode.indent() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < indent; i++) {
      s.append("  ");
    }
    return s.toString();
  }

  // Default output
  
  public String ASTNode.toString() {
    StringBuffer s = new StringBuffer();
    toString(s);
    return s.toString().trim();
  }
  
  public void ASTNode.toString(StringBuffer s) {
    //  throw new Error("ERROR: toString(StringBuffer s) not implemented for " + getClass().getName());
      s.append("WARNING: toString(StringBuffer s) not implemented for " + getClass().getName()+"\n");
  }
  public void List.toString(StringBuffer s) {
      s.append("-- in List --");
  }
  public void Opt.toString(StringBuffer s) {
      s.append("-- in Opt --");
  }

  public void Program.toString(StringBuffer s) {
    for(Iterator iter = getStmts().iterator(); iter.hasNext(); ) {
      Stmt stmt = (Stmt)iter.next();
      stmt.toString(s);
    }
  }

  // Assign Expression

  public void AssignExpr.toString(StringBuffer s) {
    getDest().toString(s);
    s.append(printOp());
    getSource().toString(s);
  }

  syn String AssignExpr.printOp() = " = ";
  eq AssignSimpleExpr.printOp() = " = ";
  
  // Colon Expression
  
  public void ColonExpr.toString(StringBuffer s) {
    getBase().toString(s);
  	s.append(" : "); 
  	if(hasIncr()) {
	    getIncr().toString(s);
	  	s.append(" : "); 
	}
    getLimit().toString(s);
  	s.append(" \n"); 
  }

  public void ParExpr.toString(StringBuffer s) {
  	boolean isNeeded = 
  		!(     (getExpr() instanceof ParExpr) 
  			|| (getExpr() instanceof Literal) 
  			|| (getExpr() instanceof Unary) 
  			|| (getExpr() instanceof Binary));
  			
    if(isNeeded) s.append("(");
    getExpr().toString(s);
    if(isNeeded) s.append(")");
  }

  // ID  
  
  public void IdUse.toString(StringBuffer s) {
  	s.append(getID()); 
  }

  public void ParseName.toString(StringBuffer s) {
  	s.append(getID()); 
  }

  // Literals
    
  public void Literal.toString(StringBuffer s) {
    s.append(getLITERAL());
  }
  
  public void StringLiteral.toString(StringBuffer s) {
    s.append("\"" + escape(getLITERAL()) + "\"");
  }
  
  public void DoubleLiteral.toString(StringBuffer s) {
    s.append(getLITERAL());
    s.append(" ");
  }

  protected static String Literal.escape(String s) {
    StringBuffer result = new StringBuffer();
    for (int i=0; i < s.length(); i++) {
      switch(s.charAt(i)) {
        case '\b' : result.append("\\b"); break;
        case '\t' : result.append("\\t"); break;
        case '\n' : result.append("\\n"); break;
        case '\f' : result.append("\\f"); break;
        case '\r' : result.append("\\r"); break;
        case '\"' : result.append("\\\""); break;
        case '\'' : result.append("\\\'"); break;
        case '\\' : result.append("\\\\"); break;
        default:
          int value = (int)s.charAt(i);
          if(value < 0x20 || (value > 0x7e))
            result.append(asEscape(value));
          else
            result.append(s.charAt(i));
      }
    }
    return result.toString();
  }
  protected static String Literal.asEscape(int value) {
    StringBuffer s = new StringBuffer("\\u");
    String hex = Integer.toHexString(value);
    for(int i = 0; i < 4-hex.length(); i++)
      s.append("0");
    s.append(hex);
    return s.toString();
  }

  // Unary expression
  
  public void Unary.toString(StringBuffer s) {
    s.append("(");
    s.append(printPreOp());
    getOperand().toString(s);
    s.append(printPostOp());
    s.append(")");
  }

  syn String Unary.printPostOp() = "";

  syn String Unary.printPreOp() = "";
  eq MinusExpr.printPreOp() = "-";
  eq PlusExpr.printPreOp() = "+";
  eq LogNotExpr.printPreOp() = "~";
  
  eq TransposeExpr.printPreOp() = "' ";
  eq ArrayTransposeExpr.printPreOp() = ".' ";
 
  // Binary Expr

  public void Binary.toString(StringBuffer s) {
    s.append("(");
    getLeftOperand().toString(s);
    s.append(printOp());
    getRightOperand().toString(s);
    s.append(")");
  }

  syn String Binary.printOp();
  eq MulExpr.printOp() = " * ";
  eq DivExpr.printOp() = " / ";
  eq LeftDivExpr.printOp() = " \\ ";
  eq PowExpr.printOp() = " ^ ";
  eq AddExpr.printOp() = " + ";
  eq SubExpr.printOp() = " - ";
  
  eq EMulExpr.printOp() = " .* ";
  eq EDivExpr.printOp() = " ./ ";
  eq ELeftDivExpr.printOp() = " .\\ ";
  eq EPowExpr.printOp() = " .^ ";

  eq AndLogicalExpr.printOp() = " && ";
  eq OrLogicalExpr.printOp() = " || ";
  eq LTExpr.printOp() = " < ";
  eq GTExpr.printOp() = " > ";
  eq LEExpr.printOp() = " <= ";
  eq GEExpr.printOp() = " >= ";
  eq EQExpr.printOp() = " == ";
  eq NEExpr.printOp() = " ~= ";

  public void MethodAccess.toString(StringBuffer s) {
    s.append(getID());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }
  public void MatrixAccess.toString(StringBuffer s) {
    s.append(getID());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }
  public void MatrixDecl.toString(StringBuffer s) {
    s.append("[");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append("; ");
        getArg(i).toString(s);
      }
    }
    s.append("]");
  }

  public void MatrixRow.toString(StringBuffer s) {
    s.append("[");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append("]");
  }

  // for MATLAB -JL
  public void CommentStmt.toString(StringBuffer s) {
    s.append(getstr());
    s.append("\n");
  }

  public void EmptyStmt.toString(StringBuffer s) {
    s.append("\n");
  }

  public void ExprStmt.toString(StringBuffer s) {
    getExpr().toString(s);
    s.append(";\n");
  }

  public void Colon.toString(StringBuffer s) {
    s.append(":");
  }
/*
  public void SwitchStmt.toString(StringBuffer s) {
    s.append("switch (");
    getExpr().toString(s);
    s.append(")");
    getBlock().toString(s);
  }

  public void ConstCase.toString(StringBuffer s) {
    s.append(indent());
    s.append("case ");
    getValue().toString(s);
    s.append(":\n");
  }

  public void DefaultCase.toString(StringBuffer s) {
    s.append(indent());
    s.append("default:\n");
  }

  public void IfStmt.toString(StringBuffer s) {
    s.append("if(");
    getCondition().toString(s);
    s.append(") ");
    getThen().toString(s);
    if(hasElse()) {
      s.append(indent());
      s.append("else ");
      getElse().toString(s);
    }
  }

  public void WhileStmt.toString(StringBuffer s) {
    s.append("while(");
    getCondition().toString(s);
    s.append(") ");
    getStmt().toString(s);
  }

  public void DoStmt.toString(StringBuffer s) {
    s.append("do ");
    getStmt().toString(s);
    s.append("while(");
    getCondition().toString(s);
    s.append(");\n");
  }

  public void ForStmt.toString(StringBuffer s) {
    s.append("for(");
    if(getNumInitStmt() > 0) {
      if(getInitStmt(0) instanceof VariableDeclaration) {
        int minDimension = Integer.MAX_VALUE;
        for(int i = 0; i < getNumInitStmt(); i++) {
          VariableDeclaration v = (VariableDeclaration)getInitStmt(i);
          minDimension = Math.min(minDimension, v.type().dimension());
        }
        VariableDeclaration v = (VariableDeclaration)getInitStmt(0);
        v.getModifiers().toString(s);
        s.append(v.type().elementType().typeName());
        for(int i = minDimension; i > 0; i--)
          s.append("[]");

        for(int i = 0; i < getNumInitStmt(); i++) {
          if(i != 0)
            s.append(",");
          v = (VariableDeclaration)getInitStmt(i);
          s.append(" " + v.name());
          for(int j = v.type().dimension() - minDimension; j > 0; j--)
            s.append("[]");
          if(v.hasInit()) {
            s.append(" = ");
            v.getInit().toString(s);
          }
        }
      }
      else if(getInitStmt(0) instanceof ExprStmt) {
        ExprStmt stmt = (ExprStmt)getInitStmt(0);
        stmt.getExpr().toString(s);
        for(int i = 1; i < getNumInitStmt(); i++) {
          s.append(", ");
          stmt = (ExprStmt)getInitStmt(i);
          stmt.getExpr().toString(s);
        }
      }
      else {
        throw new Error("Unexpected initializer in for loop: " + getInitStmt(0));
      }
    }
    
    s.append("; ");
    if(hasCondition()) {
      getCondition().toString(s);
    }
    s.append("; ");

    if(getNumUpdateStmt() > 0) {
      ExprStmt stmt = (ExprStmt)getUpdateStmt(0);
      stmt.getExpr().toString(s);
      for(int i = 1; i < getNumUpdateStmt(); i++) {
        s.append(", ");
        stmt = (ExprStmt)getUpdateStmt(i);
        stmt.getExpr().toString(s);
      }
    }
    
    s.append(") ");
    getStmt().toString(s);
  }

  public void BreakStmt.toString(StringBuffer s) {
    s.append("break ");
    if(hasLabel())
      s.append(getLabel());
    s.append(";\n");
  }

  public void ContinueStmt.toString(StringBuffer s) {
    s.append("continue ");
    if(hasLabel())
      s.append(getLabel());
    s.append(";\n");
  }

  public void ReturnStmt.toString(StringBuffer s) {
    s.append("return ");
    if(hasResult()) {
      getResult().toString(s);
    }
    s.append(";\n");
  }

  public void ThrowStmt.toString(StringBuffer s) {
    s.append("throw ");
    getExpr().toString(s);
    s.append(";\n");
  }

  public void SynchronizedStmt.toString(StringBuffer s) {
    s.append("synchronized(");
    getExpr().toString(s);
    s.append(") ");
    getBlock().toString(s);
  }

  public void TryStmt.toString(StringBuffer s) {
    s.append("try ");
    getBlock().toString(s);
    for(int i = 0; i < getNumCatchClause(); i++) {
      s.append(indent());
      getCatchClause(i).toString(s);
    }
    if(hasFinally()) {
      s.append(indent());
      s.append("finally ");
      getFinally().toString(s);
    }
  }

  public void CatchClause.toString(StringBuffer s) {
    s.append("catch (");
    getParameter().toString(s);
    s.append(") ");
    getBlock().toString(s);
  }
  
********************************************************************/

  // dump the AST to standard output

  public String ASTNode.dumpTree() {
    StringBuffer s = new StringBuffer();
    dumpTree(s, 0);
    return s.toString();
  }

  public void ASTNode.dumpTree(StringBuffer s, int j) {
    for(int i = 0; i < j; i++) {
      s.append("  ");
    }
    s.append(dumpString() + "\n");
    for(int i = 0; i < getNumChild(); i++) {
      if (getChild(i)!=null)
      	getChild(i).dumpTree(s, j + 1);
    }
  }

  public String ASTNode.dumpTreeNoRewrite() {
    StringBuffer s = new StringBuffer();
    dumpTreeNoRewrite(s, 0);
    return s.toString();
  }
  protected void ASTNode.dumpTreeNoRewrite(StringBuffer s, int indent) {
    for(int i = 0; i < indent; i++)
      s.append("  ");
    s.append(dumpString());
    s.append("\n");
    for(int i = 0; i < getNumChildNoTransform(); i++) {
      getChildNoTransform(i).dumpTreeNoRewrite(s, indent+1);
    }
  }

  syn String ASTNode.dumpString() = getClass().getName() + " [" + toString() + "]";
  eq Literal.dumpString() = getClass().getName() + " [" + getLITERAL() + "]";
  eq ParseName.dumpString() = getClass().getName() + " [" + getID() + "]";
  eq MethodAccess.dumpString() = getClass().getName() + " [" + getID() + "]";
  eq MatrixAccess.dumpString() = getClass().getName() + " [" + getID() + "]";

  public String Program.dumpTree() {
    StringBuffer s = new StringBuffer();
    for(Iterator iter = getStmts().iterator(); iter.hasNext(); ) {
      Stmt stmt = (Stmt)iter.next();
        s.append(stmt.dumpTree());
    }
    return s.toString();
  }
  
}
