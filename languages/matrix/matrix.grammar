
%class "MatrixParser";

// %terminals BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;
// DOT, LBRACE, RBRACE, 
// %terminals STATIC, GLOBAL, PERSISTENT, REPLOT; 
// %terminals CLASSDEF;
// %terminals FUNCTION; 
//%terminals IF, ELSE, ELSEIF, SWITCH, CASE, OTHERWISE, 
// DO, WHILE, FOR, BREAK, CONTINUE, RETURN, END, UNTIL;
//%terminals TRY, CATCH;
//%terminals UNWIND_PROTECT, UNWIND_PROTECT_CLEANUP, VARARGIN, VARARGOUT;

%terminals POW, EPOW, TRANSPOSE;	

%terminals LBRACK, RBRACK;
%terminals SEMICOLON, COMMA, EQ, LPAREN, RPAREN, COLON;
%terminals PLUSPLUS, MINUSMINUS, PLUS, MINUS, NOT, MULT, DIV, LEFTDIV;
%terminals EPLUS, EMINUS, EMULT, EDIV, ELEFTDIV;
%terminals LSHIFT, RSHIFT;
%terminals LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ;
%terminals AND, OR, ANDAND, OROR;
%terminals MULTEQ, DIVEQ, LEFTDIVEQ, PLUSEQ, MINUSEQ, POWEQ;
%terminals EMULTEQ, EDIVEQ, ELEFTDIVEQ, EPLUSEQ, EMINUSEQ, EPOWEQ;
%terminals LSHIFTEQ, RSHIFTEQ;
%terminals ANDEQ, OREQ;
%terminals INTEGER_LITERAL, FLOATING_POINT_LITERAL, BOOLEAN_LITERAL, SQ_STRING_LITERAL, DQ_STRING_LITERAL;
%terminals NULL_LITERAL;
%terminals IDENTIFIER;
%terminals COMMENT;

// Precedence and associativity.
%left SEMICOLON, COMMA;
%left OROR;
%left ANDAND;
%left OR;
%left AND;
%left EQEQ, NOTEQ;
%left LT, GT, LTEQ, GTEQ;
%left LSHIFT, RSHIFT;
%left COLON;
%left PLUS, MINUS, EPLUS, EMINUS;
%left MULT, DIV, LEFTDIV, EMULT, EDIV, ELEFTDIV;
%left PLUSPLUS, MINUSMINUS, NOT;
%left POW, EPOW, TRANSPOSE;	
%left LPAREN;	

%typeof INTEGER_LITERAL, FLOATING_POINT_LITERAL = "Number";
%typeof BOOLEAN_LITERAL = "Boolean";
%typeof SQ_STRING_LITERAL = "String";
%typeof DQ_STRING_LITERAL, IDENTIFIER = "String";

%goal statement_list;

// Currently, a .m file is treated as a list of statements.

statement_list =	
		statement
	|	statement_list statement
	;

statement =	
		empty_statement
	|	expression_statement
/*
	|	if_then_statement
	|	if_then_else_statement
	|	while_statement
	|	for_statement
	|	switch_statement
	|	do_statement
	|	break_statement
	|	continue_statement
	|	try_statement
*/
	;
empty_statement =
		SEMICOLON
	|	COMMENT
	;

expression_statement =
		expression SEMICOLON
	;

// Lexical Structure.
literal =	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	SQ_STRING_LITERAL
	|	DQ_STRING_LITERAL
	|	NULL_LITERAL
	;

//  Names
name	=	simple_name
	;
simple_name =	IDENTIFIER
	;

// Matrix of MATLAB -JL
matrix =
		LBRACK maxtrix_rows SEMICOLON RBRACK
	|	LBRACK maxtrix_rows RBRACK
	|	LBRACK SEMICOLON RBRACK
	|	LBRACK RBRACK
	;
	
maxtrix_rows = 	
		cell_or_matrix_row
	|	maxtrix_rows SEMICOLON cell_or_matrix_row
	;

cell_or_matrix_row =
		argument_list
	|	argument_list COMMA 
	;

// Expressions
primary =	primary_no_new_array
	;

// Don't need to add Matrix into the expression  -JL 
// because in RHS, matrix_access ==  method_invocation
primary_no_new_array =
		literal
	|	matrix
	|	LPAREN expression RPAREN
	|	method_invocation
	;
	
// Adding ':' for compatible with MATLAB matrix-access
argument_list =
		expression
	|	argument_list COMMA expression
	|	COLON
	|	argument_list COMMA COLON
	;
method_invocation =
		name LPAREN RPAREN
	|	name LPAREN argument_list RPAREN
	;
// Matrix of MATLAB -JL	
matrix_access = 
		name LPAREN argument_list RPAREN
	;
	
postfix_expression =
		primary
	|	name
	|	postfix_expression PLUSPLUS
	|	postfix_expression MINUSMINUS
	|	postfix_expression TRANSPOSE
	;
prefix_expression =
		postfix_expression
	|	binary_expression
	|	PLUSPLUS prefix_expression
	|	MINUSMINUS prefix_expression
	|	NOT prefix_expression
	|	PLUS prefix_expression
	|	MINUS prefix_expression
	;
binary_expression =
		prefix_expression POW prefix_expression
	|	prefix_expression EPOW prefix_expression 
	|	prefix_expression MULT prefix_expression
	|	prefix_expression DIV prefix_expression
	|	prefix_expression EMULT prefix_expression
	|	prefix_expression EDIV prefix_expression
	|	prefix_expression LEFTDIV prefix_expression
	|	prefix_expression ELEFTDIV prefix_expression
	|	prefix_expression PLUS prefix_expression
	|	prefix_expression MINUS prefix_expression
	|	prefix_expression EPLUS prefix_expression
	|	prefix_expression EMINUS prefix_expression
	;
// Colon expression for MATLAB -JL
colon_expression =	
		prefix_expression
	|	colon_expression COLON prefix_expression
	;
simple_expression =
		colon_expression
	|	simple_expression LSHIFT simple_expression
	|	simple_expression RSHIFT simple_expression
	|	simple_expression LT simple_expression
	|	simple_expression GT simple_expression
	|	simple_expression LTEQ simple_expression
	|	simple_expression GTEQ simple_expression
	|	simple_expression EQEQ simple_expression
	|	simple_expression NOTEQ simple_expression
	|	simple_expression AND simple_expression
	|	simple_expression OR simple_expression
	|	simple_expression ANDAND simple_expression
	|	simple_expression OROR simple_expression
	;
assignment_expression =
		simple_expression
	|	assignment
	;
assignment = left_hand_side assignment_operator assignment_expression
	;
// Adding 	matrix_access -JL 
left_hand_side =
		name
	|	matrix_access
	;
assignment_operator =
		EQ
	|	ANDEQ
	|	OREQ
	|	MULTEQ
	|	DIVEQ
	|	LEFTDIVEQ
	|	PLUSEQ
	|	MINUSEQ
	|	EMULTEQ
	|	EDIVEQ
	|	ELEFTDIVEQ
	|	EPLUSEQ
	|	EMINUSEQ
	|	LSHIFTEQ
	|	RSHIFTEQ
	|	POWEQ
	|	EPOWEQ
	;

expression =
	assignment_expression
	;
