import natlab.AspectsEngine;

aspect AspectWeaver {
	syn Boolean Program.aspectsWeave() { throw new UnsupportedOperationException(getClass().getName() + ".aspectsWeave()"); }
     
	eq FunctionList.aspectsWeave() {
		for(Function func : getFunctions()) {
			func.aspectsWeave();
		}

		return true;
    }  
    
    eq Script.aspectsWeave() {
    	AspectsEngine.weaveStmts(getStmts());
		
		return true;
    } 
    
    eq ClassDef.aspectsWeave() {
		return true;
    } 
    
    eq Aspect.aspectsWeave() {
		return true;
    }
    
    public void Function.aspectsWeave() {
    	AspectsEngine.weaveStmts(getStmts());
			
        for(Function fun : getNestedFunctions()) {
            fun.aspectsWeave();
		}
    }
    
    //////////////
    //Statements//
    //////////////
    
    syn Boolean Stmt.aspectsWeave() { throw new UnsupportedOperationException(getClass().getName() + ".aspectsWeave()"); }
    
    eq EmptyStmt.aspectsWeave() = true;
    eq GlobalStmt.aspectsWeave() = true;
    eq PersistentStmt.aspectsWeave() = true;
    eq ShellCommandStmt.aspectsWeave() = true;
    eq ReturnStmt.aspectsWeave() = true;
    eq Annotation.aspectsWeave() = true;
	eq ExpandedAnnotation.aspectsWeave() = true;
	eq VariableDecl.aspectsWeave() = true;
	eq BreakStmt.aspectsWeave()  = true;
    eq ContinueStmt.aspectsWeave()  = true;
    
    eq ForStmt.aspectsWeave() {
    	//TODO: take it out in a function
	   	//getAssignStmt().aspectsWeave();
	   	
	   	AspectsEngine.weaveStmts(getStmts());
        
        return true;
    } 
    
    eq WhileStmt.aspectsWeave() {
    	getExpr().aspectsWeave();
    	
	   	AspectsEngine.weaveStmts(getStmts());
        
        return true;
    } 
    
    eq TryStmt.aspectsWeave() {
    	AspectsEngine.weaveStmts(getTryStmts());
        AspectsEngine.weaveStmts(getCatchStmts());
        
        return true;
    } 
    
    eq SwitchStmt.aspectsWeave() {
    	getExpr().aspectsWeave();
    	
	   	for(SwitchCaseBlock sb : getSwitchCaseBlocks()) {
	   		sb.getExpr().aspectsWeave();
	   	
	   		AspectsEngine.weaveStmts(sb.getStmts());
        }
        
        if(hasDefaultCaseBlock()) {
        	AspectsEngine.weaveStmts(getDefaultCaseBlock().getStmts());
	    }
	    
	    return true;
    } 
    
    eq IfStmt.aspectsWeave() {
	   	for(IfBlock ib : getIfBlocks()) {
	   		ib.getCondition().aspectsWeave();
	   		
	   		AspectsEngine.weaveStmts(ib.getStmts());
        }
        
        if(hasElseBlock()) {
        	AspectsEngine.weaveStmts(getElseBlock().getStmts());
	    }
	    
	    return true;
    }
    
    ///////////////
    //Expressions//
    ///////////////
    
    syn Boolean Expr.aspectsWeave() {		
		return true;
    }
}

aspect ForStmtTransformation {
    private boolean ForStmt.aspectTransformed = false;
    
    public boolean ForStmt.isAspectTransformed() { return aspectTransformed; }
    public void ForStmt.setAspectTransformed(boolean aspectTransformed) { this.aspectTransformed = aspectTransformed; }
    
    /*
    rewrite ForStmt{
        when( !isAspectTransformed() )
        to natlab.ast.List<Stmt>{
    		natlab.ast.List<Stmt> lst = new natlab.ast.List<Stmt>();
    		
    		AssignStmt as_old = getAssignStmt();
    		Expr lhs = as_old.getLHS();
    		String tmpAS = "_$" + "tmpAS$";
    		String tmpFS = "_$" + "tmpFS$";
    		
    		if(lhs instanceof NameExpr){
    			NameExpr ne = (NameExpr) lhs;
    			tmpAS += ne.getName().getID();
    			tmpFS += ne.getName().getID();
    		}
    		
    		AssignStmt as_out = new AssignStmt();
    		as_out.setRHS(as_old.getRHS());
    		as_out.setLHS(new NameExpr(new Name(tmpAS)));
    		
    		AssignStmt as_for = new AssignStmt();
    		as_for.setRHS(new RangeExpr(new NameExpr(new Name("1")), new Opt<Expr>(), new ParameterizedExpr(new NameExpr(new Name("numel")), new natlab.ast.List<Expr>().add(as_out.getLHS()))));
    		as_for.setLHS(new NameExpr(new Name(tmpFS)));
    		
    		AssignStmt as_in = new AssignStmt();
    		as_in.setRHS(new ParameterizedExpr(new NameExpr(new Name(tmpAS)), new natlab.ast.List<Expr>().add(new NameExpr(new Name(tmpFS)))));
    		as_in.setLHS(as_old.getLHS());
    		
    		natlab.ast.List<Stmt> lstFor = new natlab.ast.List<Stmt>();
    		lstFor.add(as_in);
    		for(Stmt stmt : getStmts())
    			lstFor.add(stmt);
    		
    		ForStmt fs = new ForStmt();
    		fs.setAssignStmt(as_for);
    		fs.setStmtList(lstFor);
    		
    		lst.add(as_out);
    		lst.add(fs);
    		
            setAspectTransformed(true);
            return lst;
        }
    }
    */
}

aspect AspectsCorrespondingFunctions {
	
	syn boolean Program.aspectsCorrespondingFunctions() { throw new UnsupportedOperationException(getClass().getName() + ".aspectCorrespondingFunctions()"); }
     
    eq EmptyProgram.aspectsCorrespondingFunctions() = true;

    eq Script.aspectsCorrespondingFunctions() {
    	for(Stmt stmt : getStmts()) {
    		stmt.aspectsCorrespondingFunctions();
		}
		
		return true;
    }
    
    eq FunctionList.aspectsCorrespondingFunctions() {
        for(Function func : getFunctions()) {
    		func.aspectsCorrespondingFunctions();
    	}
    	
        return true;
    }
    
    eq ClassDef.aspectsCorrespondingFunctions() {

        return true;
    }
       
    public void Function.aspectsCorrespondingFunctions() {       
    	for(Stmt stmt : getStmts()) {
    		stmt.aspectsCorrespondingFunctions();
        }
        
        for(Function func : getNestedFunctions()) {
        	if(!func.getName().startsWith("_$"))
    			func.aspectsCorrespondingFunctions();
    	}
    }
    
	syn Boolean Stmt.aspectsCorrespondingFunctions() { return true; }
              
    eq ExprStmt.aspectsCorrespondingFunctions() {
    	getExpr().aspectsCorrespondingFunctions();
    	return true;
    }
    
    eq AssignStmt.aspectsCorrespondingFunctions() {
    	//getLHS().aspectsCorrespondingFunctions();
    	getRHS().aspectsCorrespondingFunctions();
    	
    	return true;
    }
    
    eq ForStmt.aspectsCorrespondingFunctions() {
	   	getAssignStmt().aspectsCorrespondingFunctions();
	   	for(Stmt stmt : getStmts()) {
           	stmt.aspectsCorrespondingFunctions();
        }
        
        return true;
    }
    
    eq WhileStmt.aspectsCorrespondingFunctions() {
    	getExpr().aspectsCorrespondingFunctions();
    	
	   	for(Stmt stmt : getStmts()) {
           	stmt.aspectsCorrespondingFunctions();
        }
        
        return true;
    } 
    
    eq TryStmt.aspectsCorrespondingFunctions() {
	   	for(Stmt stmt : getTryStmts()) {
           	stmt.aspectsCorrespondingFunctions();
        }
        for(Stmt stmt : getCatchStmts()) {
           	stmt.aspectsCorrespondingFunctions();
        }
        
        return true;
    } 
    
    eq SwitchStmt.aspectsCorrespondingFunctions() {
    	getExpr().aspectsCorrespondingFunctions();
    	
	   	for(SwitchCaseBlock sb : getSwitchCaseBlocks()) {
	   		sb.getExpr().aspectsCorrespondingFunctions();
	   	
           	for(Stmt stmt : sb.getStmts()) {
	           	stmt.aspectsCorrespondingFunctions();
	        }
        }
        
        if(hasDefaultCaseBlock()) {
	        for(Stmt stmt : getDefaultCaseBlock().getStmts()) {
		        stmt.aspectsCorrespondingFunctions();
		    }
	    }
	    
	    return true;
    } 
    
    eq IfStmt.aspectsCorrespondingFunctions() {
	   	for(IfBlock ib : getIfBlocks()) {
	   		ib.getCondition().aspectsCorrespondingFunctions();
	   		
           	for(Stmt stmt : ib.getStmts()) {
	           	stmt.aspectsCorrespondingFunctions();
	        }
        }
        
        if(hasElseBlock()) {
	        for(Stmt stmt : getElseBlock().getStmts()) {
		        stmt.aspectsCorrespondingFunctions();
		    }
	    }
	    
	    return true;
    }

	public void Name.aspectsCorrespondingFunctions() {
		//TODO ???
		//AspectsEngine.generateCorrespondingFunction(this);
	}
	
	syn boolean Expr.aspectsCorrespondingFunctions() { return true; }
 	
 	eq NameExpr.aspectsCorrespondingFunctions() {
		AspectsEngine.generateCorrespondingFunction(this);
		return true;
	}
	
	eq ParameterizedExpr.aspectsCorrespondingFunctions() {
		AspectsEngine.generateCorrespondingFunction(this);
		return true;
 	}
 	
 	eq RangeExpr.aspectsCorrespondingFunctions() {
 		getLower().aspectsCorrespondingFunctions();
 		getUpper().aspectsCorrespondingFunctions();
 		
 		if(hasIncr())
 			getIncr().aspectsCorrespondingFunctions();
 		
 		return true;
 	}

	eq CellIndexExpr.aspectsCorrespondingFunctions() {
 		getTarget().aspectsCorrespondingFunctions();
 		
 		for(Expr arg : getArgs()) {
           	arg.aspectsCorrespondingFunctions();
        }
 		
 		return true;
 	}
 	
 	eq DotExpr.aspectsCorrespondingFunctions() {
 		getTarget().aspectsCorrespondingFunctions();
 		getField().aspectsCorrespondingFunctions();
 		
 		return true;
 	}

	eq MatrixExpr.aspectsCorrespondingFunctions() {
		for(Row row : getRows()) {
			for(Expr exp : row.getElements()) {
				exp.aspectsCorrespondingFunctions();
			}
        }
        
        return true;
    }
	
	eq CellArrayExpr.aspectsCorrespondingFunctions() {
		for(Row row : getRows()) {
			for(Expr exp : row.getElements()) {
				exp.aspectsCorrespondingFunctions();
			}
        }
        
        return true;
    }
    
    eq SuperClassMethodExpr.aspectsCorrespondingFunctions() {
		getClassName().aspectsCorrespondingFunctions();
 		getFuncName().aspectsCorrespondingFunctions();
 		
 		return true;
    }
    
	eq UnaryExpr.aspectsCorrespondingFunctions() {
		getOperand().aspectsCorrespondingFunctions();
 		
 		return true;
    }
	
	eq BinaryExpr.aspectsCorrespondingFunctions() {
		getLHS().aspectsCorrespondingFunctions();
 		getRHS().aspectsCorrespondingFunctions();
 		
 		return true;
    }
	
	eq FunctionHandleExpr.aspectsCorrespondingFunctions() {
		getName().aspectsCorrespondingFunctions();
 		
 		return true;
    }
    
    eq LambdaExpr.aspectsCorrespondingFunctions() {
 		getBody().aspectsCorrespondingFunctions();
 		
 		for(Name arg : getInputParams()) {
           	arg.aspectsCorrespondingFunctions();
        }
 		
 		return true;
 	}
}