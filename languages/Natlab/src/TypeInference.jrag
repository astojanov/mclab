// =========================================================================== //
//                                                                             //
// Copyright 2008-2011 Andrew Casey, Jun Li, Jesse Doherty,                    //
//   Maxime Chevalier-Boisvert, Toheed Aslam, Anton Dubrau, Nurudeen Lameed,   //
//   Amina Aslam, Rahul Garg, Soroush Radpour, Olivier Savary Belanger,        //
//   Laurie Hendren, Clark Verbrugge and McGill University.                    //
//                                                                             //
//   Licensed under the Apache License, Version 2.0 (the "License");           //
//   you may not use this file except in compliance with the License.          //
//   You may obtain a copy of the License at                                   //
//                                                                             //
//       http://www.apache.org/licenses/LICENSE-2.0                            //
//                                                                             //
//   Unless required by applicable law or agreed to in writing, software       //
//   distributed under the License is distributed on an "AS IS" BASIS,         //
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//   See the License for the specific language governing permissions and       //
//   limitations under the License.                                            //
//                                                                             //
// =========================================================================== //

/*import annotations.ast.Type;
  import annotations.ast.Size;*/

aspect TypeInference{

    /*VariableDecl new(String id, annotations.ast.Type t){
        setID = id;
        setType = t;
        setOldID = id;
        }*/

    //fake type inference that depends on annotations

    //localGetType searches for a type of a name in the given subtree
    syn Type Program.localGetType( Name n ) = null;

    eq Script.localGetType( Name n ){
        Type t = null;
        for( Stmt stmt : getStmts() ){
            t = stmt.localGetType( n );
            if( t != null )
                return t;
        }
        return t;
    }
    //syn annotations.ast.Type Function.localGetType( Name n ){
        


    syn Type Stmt.localGetType( Name n ) = null;

    eq ExpandedAnnotation.localGetType( Name n ) =
        Type.convertAnnotation(getanno().getTypeInfo(new annotations.ast.Variable( n.getID() )));

    //TODO-JD: write eqs for all nesting stmts 

    inh Type Stmt.getType( Name n );

    eq Script.getStmt(int i).getType( Name n ) = localGetType( n );
    eq ClassDef.getMethod(int i).getType( Name n ) = localGetType( n );
    eq ClassDef.getClassEvent(int i).getType( Name n ) = localGetType( n );
    eq ClassDef.getProperty(int i).getType( Name n ) = localGetType( n );
    eq FunctionList.getFunction(int i).getType( Name n ) = localGetType( n );

    syn annotations.ast.Size Program.localGetSize( String s ) = localGetSize( new Name(s) );
    syn annotations.ast.Size Program.localGetSize( Name n) = null;

    eq Script.localGetSize( Name n ){
        annotations.ast.Size s = null;
        for( Stmt stmt : getStmts() ) {
            s = stmt.localGetSize( n );
            if( s != null )
                return s;
        }
        return s;
    }
    //TODO-JD: for other program nodes

    syn annotations.ast.Size Stmt.localGetSize( String s ) = localGetSize( new Name( s ) );
    syn annotations.ast.Size Stmt.localGetSize( Name n ) = null;

    eq ExpandedAnnotation.localGetSize( Name n ) =
        getanno().getSizeInfo( new annotations.ast.Variable( n.getID() ));

    //TODO-JD: write for all nesting stmts

    syn annotations.ast.Size Stmt.getSize( String s ) = getSize( new Name(s) );
    inh annotations.ast.Size Stmt.getSize( Name n );

    eq Script.getStmt(int i).getSize( Name n ) = localGetSize( n );
    eq ClassDef.getMethod(int i).getSize( Name n ) = localGetSize( n );
    eq ClassDef.getClassEvent(int i).getSize( Name n ) = localGetSize( n );
    eq ClassDef.getProperty(int i).getSize( Name n ) = localGetSize( n );
    eq FunctionList.getFunction(int i).getSize( Name n ) = localGetSize( n );

    //TODO JD:UPDATE TYPES  change value back to false
    private boolean VariableDecl.isRefined = true;
    rewrite VariableDecl{
        when( !isRefined )
        to VariableDecl{
            // VariableDecl decl =  new VariableDecl(getID(), getType(new Name(getID()))); //, getOriginalID());
            // Do not need to create new node, just update this 	-JL 10.04
            // This method is just link the type-annotation with decl-node
            VariableDecl decl =  this;
            Type t = getType(new Name(getID() ));
            // if the infered type is not null, update; otherwise leave it how it was
            // (NOTE: VariableDecls are instanciated with UnknownType in NameResolution)
            //TODO JD:UPDATE TYPES uncomment the if block
            /*if( t != null )
              decl.setType(t); */
            decl.isRefined = true;
            return decl;
        }
    }
}
