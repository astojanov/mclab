// =========================================================================== //
//                                                                             //
// Copyright 2008-2011 Andrew Casey, Jun Li, Jesse Doherty,                    //
//   Maxime Chevalier-Boisvert, Toheed Aslam, Anton Dubrau, Nurudeen Lameed,   //
//   Amina Aslam, Rahul Garg, Soroush Radpour, Olivier Savary Belanger,        //
//   Laurie Hendren, Clark Verbrugge and McGill University.                    //
//                                                                             //
//   Licensed under the Apache License, Version 2.0 (the "License");           //
//   you may not use this file except in compliance with the License.          //
//   You may obtain a copy of the License at                                   //
//                                                                             //
//       http://www.apache.org/licenses/LICENSE-2.0                            //
//                                                                             //
//   Unless required by applicable law or agreed to in writing, software       //
//   distributed under the License is distributed on an "AS IS" BASIS,         //
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//   See the License for the specific language governing permissions and       //
//   limitations under the License.                                            //
//                                                                             //
// =========================================================================== //

/*
 *  Simplify complex expression to several small assignment.
 *  (Not purely 3-address code)
 */
import java.util.*;

aspect Simplify {
	//-------------------------------------------------------------------------
	// int childLocation: The child-index in the stmt-list, at which location 
	// the new assign-stmt (splited from complex expression) will be added.
	// Because every time, when a new assign-stmt added to it, this child-index 
	// need to points to next location, so next adding will follow the prior one.
	// (not before the prior one)
	public static int ASTNode.childLocation = 0;
	
	// A global flag for BinaryExpr to decide whether it needs to be simplified, 
	// (>0:simplify, <=0:not), it is a global flag! Method calls could be nested!
	public static int ASTNode.inMethodCall = 0;

	// Default behavior is calling all children to do simplify.
	// Return: Expr: the new temporary variable node, used for replacing current
	//				simplified (complex) expression
	public Expr ASTNode.simplify(List stmtList, int level) {		
		for(int i = 0; i < getNumChild(); i++) {
			Expr replacementNode = getChild(i).simplify(stmtList, level);
			if(replacementNode != null) 
				setChild((T)replacementNode,i);
		}
		return null;
	}

	// Starting from ExprStmt, AssignStmt
	public Expr ExprStmt.simplify(List stmtList, int level)  {
		if(nestedLevel==1) {
			if(getParent() instanceof List) {
				List list = (List)getParent();
				this.childLocation = list.getIndexOfChild(this);
				for(int i = 0; i < getNumChild(); i++) {
					if (getChild(i)!=null) {
						Expr replacementNode = getChild(i).simplify(list, 2);
						if(replacementNode != null) {
							setChild(replacementNode,i);
						}
					}
				}
			} else {
			}
		}	
		return null;
	}
	public Expr AssignStmt.simplify(List stmtList, int level)  {
		if(nestedLevel==1) {
			if(getParent() instanceof List) {
				List list = (List)getParent();
				this.childLocation = list.getIndexOfChild(this);
				for(int i = 0; i < getNumChild(); i++) {
					if (getChild(i)!=null) {
						Expr replacementNode = getChild(i).simplify(list, 2);
						if(replacementNode != null) 
							setChild(replacementNode,i);
					}
		        }
			} else {
			}
		}	
		return null;
	}

	// Public Function, for performing simplification tranformation.
	// It only can be called by several kind of Expr, assert(this instanceof Expr);
	public Expr Expr.simplifyTranform(List stmtList, int level) {		
		return simplifyTranform(stmtList, level, this, this);
	}
	public Expr Expr.simplifyTranform(List stmtList, int level, ASTNode curExpr, ASTNode curNode) {		
		if(nestedLevel>level) {
			// (1). Create new temporary variable, by Symbol-Table interface
			// VariableDeclaration varDecl = createTempVar(type());
			String tmpName = "tmpvar" + (++VarCnt); // curExpr.getNodeID();
			
			// (2). Create NameExpr node
			NameExpr tmpNameExpr = new NameExpr(new Name(tmpName));
			
			// (3). Create AssignStmt, add to the top Stmt-List, just before current node			
			AssignStmt newAsgStmt = new AssignStmt(tmpNameExpr, (Expr)curExpr);
			newAsgStmt.setOutputSuppressed(true);
			stmtList.insertChild(newAsgStmt, childLocation);
			childLocation++;
			int bakLocation = childLocation;

			// (4). Simplify the new AssignStmt
			newAsgStmt.clearUseDefBoxes();
			newAsgStmt.generateUseBoxesList();
			newAsgStmt.simplify(stmtList, level);
			// (5). Restore the current childLocation
			// Notes: childLocation is static variable, changed along with stmtList,  
			// it will be changed in AssignStmt, IfBlock, WhileStmt, ... those has its own stmtlist
			childLocation = bakLocation;
			
			// (6) return new replacement node (another copy of NameExpr)
			return new NameExpr(new Name(tmpName));
		} else {
			return null;
		}
	}
	
	
	// stmtList: stmt-list from the top of the subtree, where we can add stmt on it
	// level : the level, all node deeper than this level need to be simplified.
	// RETURN : null, if there is no simplify need to do.
	//		    otherwise, new replacement node, 
	public Expr BinaryExpr.simplify(List stmtList, int level)  {
		// 1. Calling to next level 
		Expr lhsExpr = getLHS().simplify(stmtList, level);
		Expr rhsExpr = getRHS().simplify(stmtList, level);
		if(lhsExpr != null)
			setLHS(lhsExpr);
		if(rhsExpr != null)
			setRHS(rhsExpr);
		
		// 2. Rewrite this level
		if(inMethodCall>0)
			return simplifyTranform(stmtList, level);
		else 
			return this;
	}
	// All Transpose expression will be simplified
	// Only when Transpose expression in RHS and LHS is a variable name 
	public Expr MTransposeExpr.simplify(List stmtList, int level)  {		
		Expr op = getOperand().simplify(stmtList, level);
		if(op!=null) {
			setOperand(op);
		}
		boolean bNeed = true;
		if(getParent() instanceof AssignStmt) {
			bNeed = !(((AssignStmt)getParent()).getLHS() instanceof NameExpr);
		}
		if(bNeed) {
			return simplifyTranform(stmtList, level);
		} else {
			return null;
		}
	}	
	
	public Expr ParameterizedExpr.simplify(List stmtList, int level)  {
		boolean bLinearIndexing = false;
		inMethodCall++;
		// 1. Calling to next level 
		List<Expr> args = getArgs();	// get the updated tree
		int i=0;
		for(Expr arg : args) {
			// if the case of ":" as an argument
			if(arg instanceof ColonExpr) {
				bLinearIndexing = true; 
			}
			Expr argExpr = arg.simplify(stmtList, level);
			if(argExpr != null)
				setArg(argExpr, i);
			i++;
		}
		// If just one argument is :, then it's normal indexing
		if(i>1)
			bLinearIndexing = false;
		inMethodCall--;
		// 2. Rewrite this level, split into a single assignment
		if(bLinearIndexing) 
			return null;
		else
			return simplifyTranform(stmtList, level);
	}
	
	// (1) Matrix, should be split from the BinaryExpr, ParameterizedExpr
	// (2) Inside the matrix, just split the elements of each row, the row itself
	// 		will not change
	public Expr MatrixExpr.simplify(List stmtList, int level)  {
		// 1. Calling to next level 
		int bOld = inMethodCall;
		inMethodCall = 1;
		List<Row> rows = getRows();
		int i=0;
		for(Row row : rows) {
			// Row simplification will NOT change the row itself 
			row.simplify(stmtList, level);
		}
		inMethodCall = bOld;
		// 2. Rewrite this level, split into a single assignment
		return simplifyTranform(stmtList, level);
	}
	public Expr Row.simplify(List stmtList, int level)  {
		// 1. Calling to next level 
		List<Expr> elements = getElements();
		int i=0;
		for(Expr element : elements) {
			Expr expr = element.simplify(stmtList, level);
			if(expr != null)
				setElement(expr, i);
			i++;
		}
		// 2. Don't change the row itself 
		return null;
	}
	// Don't simplify the condition of IfBlock, While 
 	public Expr IfStmt.simplify(List stmtList, int level)  {
		// Create temporary assignment statement for condition expr
		if(getParent() instanceof List) {
			stmtList = (List)getParent();
			List list = (List)getParent();
		        for(IfBlock block : getIfBlocks()) {	        	
		        	Expr condExpr = block.getCondition();
	
		     		if(condExpr.getNodeID()>0) {
		     			this.childLocation = list.getIndexOfChild(this);
			     		Expr tmpCondExpr =  condExpr.simplifyTranform(list,-1,condExpr,this);
			    		block.setCondition(tmpCondExpr);
		     		}
		        }
		}

		for(IfBlock block : getIfBlocks()) {
			block.simplify(stmtList, level);
		}
		if(hasElseBlock()) {
			getElseBlock().simplify(stmtList, level);
		}
		
		return null;
	}
 
 	public Expr IfBlock.simplify(List stmtList, int level)  {
		// Skip the condition expression 
		// Restart the count of level and stmt-list for following stmt
		for(Stmt stmt : getStmts()) {
			stmt.simplify(getStmtList(), 0);
		}
		return null;
	}

	public Expr WhileStmt.simplify(List stmtList, int level)  {
		stmtList = (List)getStmtList();
		Expr condExpr = getExpr();

 		if(condExpr.getNodeID()>0) {
 			// set condition to true (1)
 			this.childLocation = 0;
 			// While (cond) ==> DO ; if(cond) ...
 			// (1>0)
 			setExpr(new GTExpr(
 					new ast.IntLiteralExpr(new natlab.DecIntNumericLiteralValue("1")),
 					new ast.IntLiteralExpr(new natlab.DecIntNumericLiteralValue("0")))
 			);

 			// Create new if statement to handle the condition
 			List tmpList = new List<Stmt>();
			Expr tmpCondExpr =  condExpr.simplifyTranform(tmpList,-1,condExpr,this);
			IfStmt tmpIfStmt  = new IfStmt();
			IfBlock tmpIfBlock = new IfBlock(tmpCondExpr, getStmtList());
			ElseBlock tmpElseBlock = new ElseBlock(new List<Stmt>().add(new BreakStmt()));
			tmpIfStmt.setIfBlockList(new List<IfBlock>().add(tmpIfBlock));
			tmpIfStmt.setElseBlock(tmpElseBlock);
			tmpList.add(tmpIfStmt);
			setStmtList(tmpList);
 		}
		for(Stmt stmt : getStmts()) {
			stmt.simplify(getStmtList(), 0);
		}
		return null;
	}
	public Expr RangeExpr.simplify(List stmtList, int level)  {
		// If there is binary express in any of low:inc:upp,
		// then simplify it.
		// 1. Calling to next level 
		int bOld = inMethodCall;
		inMethodCall = 1;
		Expr lowExpr = getLower().simplify(stmtList, level);
		Expr upExpr = getUpper().simplify(stmtList, level);
		if(lowExpr != null)
			setLower(lowExpr);
		if(upExpr != null)
			setUpper(upExpr);
		if(hasIncr()) {
			Expr incrExpr = getIncr().simplify(stmtList, level);
			if(incrExpr != null)
				setIncr(incrExpr);
		}
		
		inMethodCall = bOld;
		// If it's part of ParameterizedExpr, mostly are indexing, then skip
		if(inMethodCall>0) { // (getParent() instanceof natlab.ast.List) {	
			return null;
		} else {
		// 2. Rewrite this level  // 
			return simplifyTranform(stmtList, level);
		}
	}

	public Expr NameExpr.simplify(List stmtList, int level)  {
		if(getVarName().equals("rand") || getVarName().equals("randn")) {
			return simplifyTranform(stmtList, 1);
		} else {
			return null;
		}
	}
	

	//-------------------------------------------------------------------------
	// Get constant R-Value, LiteralExpr: FPLiteralExpr, IntLiteralExpr, StringLiteralExpr
	// Currently only suppot FP/Int constant
	public Expr ASTNode.getRValue() {
		return null;
	}
	
	public Expr Expr.getRValue() {
		if(this instanceof FPLiteralExpr || this instanceof IntLiteralExpr)	{
			return this;
		} else {		
			return null;
		}
	}
	public Expr BinaryExpr.getRValue() {
		// 1. Calling to next level 
		Expr lhsExpr = getLHS().getRValue();
		Expr rhsExpr = getRHS().getRValue();
		if(lhsExpr != null  && rhsExpr != null) {
			// For floating point calculation
			if(lhsExpr instanceof IntLiteralExpr 
				&& rhsExpr instanceof IntLiteralExpr) {
				if(this instanceof PlusExpr) {
					return new IntLiteralExpr(
							new natlab.DecIntNumericLiteralValue(
							((IntLiteralExpr)lhsExpr).getValue().getValue().add(((IntLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MinusExpr) {
					return new IntLiteralExpr(
							new natlab.DecIntNumericLiteralValue(
							((IntLiteralExpr)lhsExpr).getValue().getValue().subtract(((IntLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MTimesExpr) {
					return new IntLiteralExpr(
							new natlab.DecIntNumericLiteralValue(
							((IntLiteralExpr)lhsExpr).getValue().getValue().multiply(((IntLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MDivExpr) {
					return new IntLiteralExpr(
							new natlab.DecIntNumericLiteralValue(
							((IntLiteralExpr)lhsExpr).getValue().getValue().divide(((IntLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				}
				
			} else {	// TODO: Need splite different type of FPLiteralExpr, IntLiteralExpr
				// Perform calculation
				if(this instanceof PlusExpr) {
					return new FPLiteralExpr(
						new natlab.FPNumericLiteralValue(
						((FPLiteralExpr)lhsExpr).getValue().getValue().add(((FPLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MinusExpr) {
					return new FPLiteralExpr(
							new natlab.FPNumericLiteralValue(
							((FPLiteralExpr)lhsExpr).getValue().getValue().subtract(((FPLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MTimesExpr) {
					return new FPLiteralExpr(
							new natlab.FPNumericLiteralValue(
							((FPLiteralExpr)lhsExpr).getValue().getValue().multiply(((FPLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} else if(this instanceof MDivExpr) {
					return new FPLiteralExpr(
							new natlab.FPNumericLiteralValue(
							((FPLiteralExpr)lhsExpr).getValue().getValue().divide(((FPLiteralExpr)rhsExpr).getValue().getValue()).toString()));
				} 
			}
				
		} 
		return null;
	}
	
	
	//-------------------------------------------------------------------------
	// Constant Propagation
	// TODO: move to proper file; temporarily save here
	// Expr lExpr: could be LiteralExpr, NameExpr, 
	// Return: 
	//	Expr: when a node found itself should be replaced, 
	//		return the new expr(lExpr)
	//		Otherwise: return null
	public Expr ASTNode.constantPropagation(String varName, Expr lExpr) {		
		for(int i = 0; i < getNumChild(); i++) {
			Expr replacementNode = getChild(i).constantPropagation(varName, lExpr);
			if(replacementNode != null) 
				setChild((T)replacementNode,i);
		}
		return null;
	}
	
	public Expr NameExpr.constantPropagation(String varName, Expr lExpr) {
		if (varName.equals(this.getName().getID())) {
			return lExpr;
		}
		return null;
	}
	// Avoid LHS variable name being change
	public Expr AssignStmt.constantPropagation(String varName,  Expr lExpr) {
		Expr lhs = getLHS();
		if(lhs instanceof ParameterizedExpr) {
	        for(Expr arg : ((ParameterizedExpr) lhs).getArgs()) {
		        arg.constantPropagation(varName, lExpr);
	        }
		}
		getRHS().constantPropagation(varName, lExpr);
		return null;
	}
}
