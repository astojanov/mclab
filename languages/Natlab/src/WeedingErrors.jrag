//Weeding Errors

aspect WeedingErrors {
    //default - exception
    syn boolean ASTNode.getWeedingErrors() { throw new UnsupportedOperationException(getClass().getName() + ".getWeedingErrors()"); }
     
    eq EmptyProgram.getWeedingErrors() {
        return true;
    }

    eq Script.getWeedingErrors() {
        for(Stmt stmt : getStmts())
    		if(stmt instanceof AssignStmt)
            	stmt.getWeedingErrors();
            	
    	return true;
    }
    
    eq FunctionList.getWeedingErrors() {
        for(Function func : getFunctions())
           func.getWeedingErrors();
       
        return true;
    }
    
    eq Function.getWeedingErrors() {       
        if(getParent().getParent() instanceof Methods) {
        	String name = getName();
        	ClassDef grandParent = (ClassDef) getParent().getParent().getParent().getParent();
        	
	  		if(grandParent.getName().compareTo(getName()) == 0) {
		  		if(getOutputParams().getNumChild() == 0) {
	               	error(getPosString(), "A class constructor must at least return an object constructed as output");
				}
			}
        }
        
    	for(Stmt stmt : getStmts())
            if(stmt instanceof AssignStmt)
            	stmt.getWeedingErrors();

        for(Function func : getNestedFunctions())
            func.getWeedingErrors();

    	return true;
    }

    eq ClassDef.getWeedingErrors() {
		String classAttributes = "ConstructOnLoad,InferiorClasses,Hidden,Sealed,";
		String match = "";
			
        for(Attribute attr : getAttributes()) {
        	if(classAttributes.indexOf(attr.getKey()+",") == -1) {
            	error(attr.getPosString(), attr.getKey() + " is not a valid class attribute");
           	} else if(match.indexOf(attr.getKey()) >= 0) {
           		error(attr.getPosString(), attr.getKey() + " has already been defined as class attribute");
           	} else {
           		match = match + attr.getKey() + ",";
           	}
        }

		for(Properties prop : getPropertys())
            prop.getWeedingErrors();
        
        for(Methods methods : getMethods())
            methods.getWeedingErrors();
        
        for(ClassEvents events : getClassEvents())
            events.getWeedingErrors();
        
        return true;
    }
   
    eq Properties.getWeedingErrors() {       
        Boolean constExists = false, depExists = false;
        String propertyAttributes = "Abstract,Constant,Dependent,GetAccess,SetAccess,GetObservable,SetObservable,Hidden,Transient,";	
        String match = "";
        
        for(Attribute attr : getAttributes()) {
        	if(propertyAttributes.indexOf(attr.getKey()+",") == -1) {
            	error(attr.getPosString(), attr.getKey() + " is not a valid property attribute");            	
           	} else if(match.indexOf(attr.getKey()) >= 0) {
           		error(attr.getPosString(), attr.getKey() + " has already been defined as property attribute");
           	} else {
           		match = match + attr.getKey() + ",";
           	}
           	
           	//ToDo-TA: also add value=true condition below
           	if(attr.getKey().compareTo("Abstract") == 0 && attr.getExpr().getPrettyPrintedLessComments().compareTo("true") == 0) {
           		ClassDef parent = (ClassDef) getParent().getParent();
           		for(Methods mthd : parent.getMethods()) {
		            for(PropertyAccess pty : mthd.getPropAccs()) {
		            	for(Property prop : getPropertys()) {
			            	if(prop.getName().compareTo(pty.getName()) == 0) {
			            		error(pty.getPosString(), "Property access methods can not be defined for abstract property: " + prop.getName());
			            	}
		            	}
		            }
		        }
		        
		        for(Property prop : getPropertys())
		        	if(prop.getExpr().getPrettyPrintedLessComments().compareTo("[]") != 0)
		        		error(prop.getExpr().getPosString(), "Initial value can not be specified for abstract property: " + prop.getName());            			
		        
		        
		        for(Attribute pAttr : parent.getAttributes()) {
		        	//ToDo-TA: also add value=true condition below
		        	if(pAttr.getKey().compareTo("Sealed") == 0 && pAttr.getExpr().getPrettyPrintedLessComments().compareTo("true") == 0) {
		            	error(attr.getPosString(), "Abstract properties are not allowed in a sealed class");		            	
		           	}
		        }
			}
           	
           	//ToDo-TA: also add value=true conditions below
           	if(attr.getKey().compareTo("Constant") == 0 && attr.getExpr().getPrettyPrintedLessComments().compareTo("true") == 0) 
           		constExists = true;
           	if(attr.getKey().compareTo("Dependent") == 0 && attr.getExpr().getPrettyPrintedLessComments().compareTo("true") == 0) 
           		depExists = true;
        }
        
        if(constExists && depExists) {
        	error(getPosString(), "Constant properties can not be Dependent and vice-versa");        	
       	}
        
        for(Property prop : getPropertys()) {
        	String name = prop.getName();
            ClassDef grandParent = (ClassDef) getParent().getParent();
            
  			if(grandParent.getName().compareTo(name) == 0) {
        		error(prop.getPosString(), "A property may not use the same name as the name of the class");				
			}
        }

        return true;
    } 
    
    eq Methods.getWeedingErrors() {       
        String methodAttributes = "Abstract,Access,Hidden,Sealed,Static,";
        String match = "";
        	
        for(Attribute attr : getAttributes()) {
        	if(methodAttributes.indexOf(attr.getKey()+",") == -1) {
            	error(attr.getPosString(), attr.getKey() + " is not a valid method attribute");            	
           	} else if(match.indexOf(attr.getKey()) >= 0) {
           		error(attr.getPosString(), attr.getKey() + " has already been defined as method attribute");
           	} else {
           		match = match + attr.getKey() + ",";
           	}
           	
           	if(attr.getKey().compareTo("Abstract") == 0 && attr.getExpr().getPrettyPrintedLessComments().compareTo("true") == 0) {
            	if(getPropAccs().getNumChild() > 0 || getFunctions().getNumChild() > 0) {
            		error(attr.getPosString(), "Only function signatures are valid inside abstract methods block");            		
            	}
           	}
        }
        
        for(Signature sign : getSignatures())
            sign.getWeedingErrors();
        
        for(PropertyAccess prop : getPropAccs())
            prop.getWeedingErrors();
        
        for(Function func : getFunctions())
            func.getWeedingErrors();
        
        return true;
    }
    
    eq Signature.getWeedingErrors() {
 		String name = getName();
  		ClassDef grandParent = (ClassDef) getParent().getParent().getParent().getParent();
  		
  		if(grandParent.getName().compareTo(getName()) == 0)
        	error(getPosString(), "A class constructor must not be external");			
		
    	return true;
    }
    
    eq PropertyAccess.getWeedingErrors() {
		Methods parent = (Methods) getParent().getParent();
		if(parent.getAttributes().getNumChild() > 0){
			error(getPosString(), "Property access method should be in a methods block with no attributes");			
		}
		
		String access = getAccess();
		if(access.compareTo("set") != 0 && access.compareTo("get") != 0) {
			error(getPosString(), access + " is neither get or set in property access method");			
        }
        else if(access.compareTo("set") == 0){
        	if(getInputParams().getNumChild() < 2) {
               	error(getPosString(), "A property set method must have an object and its value as input");				
			}
        }
        else if(access.compareTo("get") == 0){
        	if(getInputParams().getNumChild() < 1) {
               	error(getPosString(), "A property get method must have an object as input");				
			}
			if(getOutputParams().getNumChild() < 1) {
               	error(getPosString(), "A property get method must return its value as output");				
			}
        }
        
        String name = getName();
        Boolean match = false; 
        ClassDef grandParent = (ClassDef) parent.getParent().getParent();
        for(Properties prop : grandParent.getPropertys()) {
            for(Property pty : prop.getPropertys()) {
            	if(name.compareTo(pty.getName()) == 0) {
            		match = true;
            		break;
            	}
            }
        }
        if(!match) {
        	error(getPosString() + name + " is not a valid property in property access method");			
        }
                
        for(Stmt stmt : getStmts())
            if(stmt instanceof AssignStmt)
            	stmt.getWeedingErrors();
        
        for(Function func : getNestedFunctions())
            func.getWeedingErrors();

        return true;
    }
    
    eq ClassEvents.getWeedingErrors() {     
        String eventAttributes = "Hidden,ListenAccess,NotifyAccess,";
        String match = "";
        
        for(Attribute attr : getAttributes()) {
        	if(eventAttributes.indexOf(attr.getKey()+",") == -1) {
            	error(attr.getPosString(), attr.getKey() + " is not a valid event attribute");            	
           	} else if(match.indexOf(attr.getKey()) >= 0) {
           		error(attr.getPosString(), attr.getKey() + " has already been defined as event attribute");
           	} else {
           		match = match + attr.getKey() + ",";
           	}
        }

		for(Event eve : getEvents()) {
			String name = eve.getName();
            ClassDef grandParent = (ClassDef) getParent().getParent();
  			
  			if(grandParent.getName().compareTo(name) == 0) {
        		error(eve.getPosString(), "An event may not use the same name as the name of the class");				
			}
        }
        
        return true;
    }

    eq AssignStmt.getWeedingErrors() {
    	Expr lhs = getLHS();
    	
		if(lhs instanceof LValueExpr) {
			if(lhs instanceof MatrixExpr){
				lhs.getWeedingErrors();
			}
    	} else {
    		error(lhs.getPosString(), "Left hand side of assignment statement is not a valid expression");			
    	}  	   
    	return true;
    }  
    
	eq MatrixExpr.getWeedingErrors() {    	
		Integer noOfRows = 0;
		for(Row row : getRows()) {
			noOfRows++;
			if(noOfRows > 1) {
	        	error(row.getPosString(), "Left hand side of assignment statement can only have a single-row matrix");						
				break;
	        }
			
			for(Expr exp : row.getElements()) {
				if(exp instanceof LValueExpr) {
					if(exp instanceof MatrixExpr) {
						exp.getWeedingErrors();
					}
				} else {
					error(exp.getPosString(), "Left hand side of assignment statement is not a valid expression");			
				}  	   
			}
        }
        
    	return true;
    }  
}