// =========================================================================== //
//                                                                             //
// Copyright 2008-2011 Andrew Casey, Jun Li, Jesse Doherty,                    //
//   Maxime Chevalier-Boisvert, Toheed Aslam, Anton Dubrau, Nurudeen Lameed,   //
//   Amina Aslam, Rahul Garg, Soroush Radpour, Olivier Savary Belanger,        //
//   Laurie Hendren, Clark Verbrugge and McGill University.                    //
//                                                                             //
//   Licensed under the Apache License, Version 2.0 (the "License");           //
//   you may not use this file except in compliance with the License.          //
//   You may obtain a copy of the License at                                   //
//                                                                             //
//       http://www.apache.org/licenses/LICENSE-2.0                            //
//                                                                             //
//   Unless required by applicable law or agreed to in writing, software       //
//   distributed under the License is distributed on an "AS IS" BASIS,         //
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//   See the License for the specific language governing permissions and       //
//   limitations under the License.                                            //
//                                                                             //
// =========================================================================== //

//Weeding Filter for unsupported stuff in pass 1

aspect WeedingFilter {
    //default - exception
    syn boolean ASTNode.getWeedingFilter() { throw new UnsupportedOperationException(getClass().getName() + ".getWeedingFilter()"); }
     
    eq EmptyProgram.getWeedingFilter() = true;

    eq Script.getWeedingFilter() {
    	for(Stmt stmt : getStmts()) {
    		stmt.getWeedingFilter();
		}
		
		return true;
    }
    
    eq FunctionList.getWeedingFilter() {
        for(Function func : getFunctions()) {
    		func.getWeedingFilter();
    	}
    	
        return true;
    }
    
    eq Function.getWeedingFilter() {       
    	for(Stmt stmt : getStmts()) {
    		stmt.getWeedingFilter();
        }
        
        if(getNumNestedFunction() > 0) {
			error(getNestedFunction(0).getPosString(), "Nested functions are not supported");
		}
		
        return true;
    }

    eq ClassDef.getWeedingFilter() {
		error(getPosString(), "Classes are not supported");
        return true;
    }
   
    //////////////
    //Statements//
    //////////////
    
    eq EmptyStmt.getWeedingFilter() = true;
    eq GlobalStmt.getWeedingFilter() = true;
    eq PersistentStmt.getWeedingFilter() = true;
    eq ShellCommandStmt.getWeedingFilter() = true;
    eq ReturnStmt.getWeedingFilter() = true;
    eq Annotation.getWeedingFilter() = true;
	eq ExpandedAnnotation.getWeedingFilter() = true;
	eq VariableDecl.getWeedingFilter() = true;
	eq BreakStmt.getWeedingFilter()  = true;
    eq ContinueStmt.getWeedingFilter()  = true;
    
    eq ExprStmt.getWeedingFilter() {
    	getExpr().getWeedingFilter();
    	return true;
    }
    
    eq AssignStmt.getWeedingFilter() {
    	getLHS().getWeedingFilter();
    	getRHS().getWeedingFilter();
    	
    	return true;
    }
    
    eq ForStmt.getWeedingFilter() {
	   	getAssignStmt().getWeedingFilter();
	   	for(Stmt stmt : getStmts()) {
           	stmt.getWeedingFilter();
        }
        
        return true;
    } 
    
    eq WhileStmt.getWeedingFilter() {
    	getExpr().getWeedingFilter();
    	
	   	for(Stmt stmt : getStmts()) {
           	stmt.getWeedingFilter();
        }
        
        return true;
    } 
    
    eq TryStmt.getWeedingFilter() {
	   	for(Stmt stmt : getTryStmts()) {
           	stmt.getWeedingFilter();
        }
        for(Stmt stmt : getCatchStmts()) {
           	stmt.getWeedingFilter();
        }
        
        return true;
    } 
    
    eq SwitchStmt.getWeedingFilter() {
    	getExpr().getWeedingFilter();
    	
	   	for(SwitchCaseBlock sb : getSwitchCaseBlocks()) {
	   		sb.getExpr().getWeedingFilter();
	   	
           	for(Stmt stmt : sb.getStmts()) {
	           	stmt.getWeedingFilter();
	        }
        }
        
        if(hasDefaultCaseBlock()) {
	        for(Stmt stmt : getDefaultCaseBlock().getStmts()) {
		        stmt.getWeedingFilter();
		    }
	    }
	    
	    return true;
    } 
    
    eq IfStmt.getWeedingFilter() {
	   	for(IfBlock ib : getIfBlocks()) {
	   		ib.getCondition().getWeedingFilter();
	   		
           	for(Stmt stmt : ib.getStmts()) {
	           	stmt.getWeedingFilter();
	        }
        }
        
        if(hasElseBlock()) {
	        for(Stmt stmt : getElseBlock().getStmts()) {
		        stmt.getWeedingFilter();
		    }
	    }
	    
	    return true;
    } 
    
    ///////////////
    //Expressions//
    ///////////////
    
    eq Expr.getWeedingFilter() {
    	if(this instanceof FunctionHandleExpr) {
			error(getPosString(), "Function handles are not supported");
		}
		else if(this instanceof LambdaExpr) {
			error(getPosString(), "Anonymous functions are not supported");
		}
		else if(this instanceof SuperClassMethodExpr) {
			error(getPosString(), "Superclass method calls are not supported");
		}
		else if(this instanceof ParameterizedExpr) {
			ParameterizedExpr pe = (ParameterizedExpr)this;
			Expr te = pe.getTarget();
			if(te instanceof SuperClassMethodExpr) {
				error(te.getPosString(), "Superclass method calls are not supported");
			}
		}
		
		return true;	
    }
}