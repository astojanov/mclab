%package "natlab.tame.builtin.classprop";
%import "natlab.tame.builtin.classprop.ast.*";
%import "java.util.*";
%class "ClassPropParser";


%terminals NUMBER, LPAREN, RPAREN, OROR, OR, COMMA, MULT, QUESTION, ARROW, ID;
%terminals COERCE, TYPESTRING;

%left  CALL;
%left  RPAREN;
%left  MULT, QUESTION;
%left  OR;
%left  CHAIN;
%left  ARROW;
%left  COMMA;
%left  OROR;


%typeof NUMBER = "Number";
%typeof ID = "String";
%typeof expr, pexpr, lexpr, eqn = "CP";
%typeof list = "CPList";

%goal eqn;

eqn
    = list.l                            {: return l.asUnion(); :}
    ;
    
lexpr 
	= expr.a ARROW expr.b             {: return new CPMap   (a, b); :}
	| lexpr.a OROR lexpr.b            {: return new CPUnion (a, b); :}
	| pexpr
	;

expr
	= expr.a QUESTION                  {: return Functions.get("?",new CPList(a,null)); :}
	| expr.a MULT                      {: return Functions.get("*",new CPList(a,null)); :}	
	| expr.a expr.b @ CHAIN            {: return new CPChain(a,b);   :}
	| expr.a OR expr.b                 {: return new CPUnion (a, b); :}
    | NUMBER.n                         {: return new CPNum(n.intValue()); :}
	| ID.s                             {: return Functions.get(s);   :}
	| LPAREN lexpr.e RPAREN            {: return e;                  :}
	| COERCE LPAREN lexpr.a COMMA lexpr.b RPAREN  @CALL     {: return new CPCoerce(a,b); :}
	| TYPESTRING LPAREN list.l RPAREN  @CALL {: return Functions.get("typeString",l); :}
	;

list
    = lexpr.e                           {: return new CPList(e,null); :}
    | lexpr.a COMMA list.l              {: return new CPList(a,l);    :}
    ;

pexpr
	= expr
    ;






