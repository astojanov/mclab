import sys
import classProp
# in this file the code that gets generated by the tags gets printed
# the genBuiltin.py calls, for every encountered tag, a function with
# the same name in this module. The function will always be called
# with the same arguments, and should return string representing java
# code that will by inserted in the code for the Builtin where the tag
# occured. A tag has a name, and arguments. See the builtins.csv and
# genBuiltin.py
#
# functions are called with the arguments (builtin(Builtin obj), tagArgs(string), implements-set(string-set))
DEBUG = True;
def processTags(builtin, iset):
    code = "";
    if (DEBUG and len(builtin.tags) > 0): print "\n***** tag processing for:",builtin.name,"*******\ndefined tags: ",builtin.tags
    for tagName in builtin.tags.keys():
       tagArgs = builtin.tags[tagName];
       # the function that deals with the tag needs to have the same name as the tag 
       try:
           f = eval(tagName)
       except:
           raise Exception("tag '"+tagName+"' used for function "+builtin.name+" is not defined");
       code += f(builtin, tagArgs, iset)
    return code;

# *** Helper Functions **********************************************

# takes a string s which should be a comma separated list, sorrounded
# by parenthesis or not, such that eval(s) is always a tuple
# - it strips, removes surrounding parthesis, and adds ',', unless it's
#   empty, in which case it returns '()'
# '(a,b)' -> 'a,b,'         '(a)' -> 'a,'      'a,b' -> 'a,b,'         
# '()'    -> '()'           ''    -> '()'
def makeArgString(s):
  s = s.strip()
  if (s[0] == '(' and s[-1] == ')'): s = s[1:-1]
  if (len(s) == 0): return '()'
  return s+','


# *** processing tags *********************************************************
def s(builtin, tagArgs, iset):
  return ''


def args(builtin, tagArgs, iset):
  # add the interface
  iset.add("ArityDefined");
  # parse arg
  dict = {'inf': 'ArityDefined.INFINITE'};
  if (len(tagArgs) == 0):minmax = ()
  else: minmax = eval(makeArgString(tagArgs),dict);
  print minmax
  # if only one arg is defined, we set the second to the first
  if (len(minmax) == 1): minmax = minmax+minmax
  if (len(minmax) == 0): return ""
  return """
        public int getMaxNumOfArgs(){{ return {0}; }}
        public int getMinNumOfArgs(){{ return {1}; }}
        public boolean isVariadic(){{ return {0}=={1}; }}
""".format(*minmax)


# **** class propagation tags *******************************************
# actually defined in its own file
def Class(builtin, tagArgs, iset):
    return classProp.Class(builtin, tagArgs, iset);
# actually defined in its own file
def MatlabClass(builtin, tagArgs, iset):
    return classProp.MatlabClass(builtin, tagArgs, iset);
# abstract should be taken care of by genbuiltins
def abstract(builtin, tagArgs, iset):
    return ""

def Class2(builtin, tagArgs, iset):
    iset.add("HasClassPropagationInfo"); # add the interface
    treeString = tagArgs.strip()[1:-1];  # building string to parse - remove parentheses
    
    # java expr for parent info - find if tag 'Class' is defined for a parent
    if (builtin.parent and builtin.parent.getAllTags().has_key('Class')):
      parentInfo = 'super.getClassPropagationInfo2()'
    else:
      parentInfo = 'new CPNone()'
    
    # deal with the matlabClass info - check if there is a matlabClass tag defined - if not, emit the default
    if (not builtin.getAllTags().has_key('MatlabClass')):
        matlabClassMethod = """
        public CP getMatlabClassPropagationInfo2(){{
            return getClassPropagationInfo();
        }}
"""; # there's no explicit tag for matlab - just return the class info
    else:
        matlabClassMethod = ''; # emit nothing - the matlabClass tag will deal with it

    # produce code
    return matlabClassMethod+"""
        private CP classPropInfo2 = null;
        public CP getClassPropagationInfo2(){{
            //set classPropInfo if not defined
            if (classPropInfo2 == null){{
                classPropInfo2 = ClassPropTool.parse("{treeString}");
                classPropInfo2.setVar("parent",{parentInfo});
                classPropInfo2.setVar("matlab",getMatlabClassPropagationInfo());
            }}
            return classPropInfo2;
        }}
""".format(treeString=treeString, javaName=builtin.javaName, parentInfo=parentInfo);




def MatlabClass2(builtin, tagArgs, iset):
    return ""


