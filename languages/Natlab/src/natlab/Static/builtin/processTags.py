import sys
import classProp
# in this file the code that gets generated by the tags gets printed
# the genBuiltin.py calls, for every encountered tag, a function with
# the same name in this module. The function will always be called
# with the same arguments, and should return string representing java
# code that will by inserted in the code for the Builtin where the tag
# occured. A tag has a name, and arguments. See the builtins.csv and
# genBuiltin.py
#
# functions are called with the arguments (builtin(Builtin obj), tagArgs(string), implements-set(string-set))
DEBUG = True;
def processTags(builtin, iset):
    code = "";
    if (DEBUG and len(builtin.tags) > 0): print "\n***** tag processing for:",builtin.name,"*******\ndefined tags: ",builtin.tags
    for tagName in builtin.tags.keys():
       tagArgs = builtin.tags[tagName];
       # the function that deals with the tag needs to have the same name as the tag 
       try:
           f = eval(tagName)
       except:
           raise Exception("tag '"+tagName+"' used for function "+builtin.name+" is not defined");
       code += f(builtin, tagArgs, iset)
    return code;

# *** Helper Functions **********************************************

# takes a string s which should be a comma separated list, sorrounded
# by parenthesis or not, such that eval(s) is always a tuple
# - it strips, removes surrounding parthesis, and adds ',', unless it's
#   empty, in which case it returns '()'
# '(a,b)' -> 'a,b,'         '(a)' -> 'a,'      'a,b' -> 'a,b,'         
# '()'    -> '()'           ''    -> '()'
def makeArgString(s):
  s = s.strip()
  if (s[0] == '(' and s[-1] == ')'): s = s[1:-1]
  if (len(s) == 0): return '()'
  return s+','


# *** processing tags *********************************************************
def s(builtin, tagArgs, iset):
  return ''


def args(builtin, tagArgs, iset):
  # add the interface
  iset.add("ArityDefined");
  # parse arg
  dict = {'inf': 'ArityDefined.INFINITE'};
  if (len(tagArgs) == 0):minmax = ()
  else: minmax = eval(makeArgString(tagArgs),dict);
  print minmax
  # if only one arg is defined, we set the second to the first
  if (len(minmax) == 1): minmax = minmax+minmax
  if (len(minmax) == 0): return ""
  return """
        public int getMaxNumOfArgs(){{ return {0}; }}
        public int getMinNumOfArgs(){{ return {1}; }}
        public boolean isVariadic(){{ return {0}=={1}; }}
""".format(*minmax)


# **** class propagation tags *******************************************
# actually defined in its own file
def Class(builtin, tagArgs, iset):
    return classProp.Class(builtin, tagArgs, iset);
# actually defined in its own file
def MatlabClass(builtin, tagArgs, iset):
    return classProp.MatlabClass(builtin, tagArgs, iset);
