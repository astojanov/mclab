# in this file the code that gets generated by the tags gets printed
# the genBuiltin.py calls, for every encountered tag, a function with
# the same name in this module. The function will always be called
# with the same arguments, and should return string representing java
# code that will by inserted in the code for the Builtin where the tag
# occured. A tag has a name, and arguments. See the builtins.csv and
# genBuiltin.py
#
# functinos get called with the following arguments:
# (name, java-name, parent-java-name, is-abstract, tag-arguments(string), implements-set(string-set), tag-map)


# *** Helper Functions **********************************************

# takes a string s which should be a comma separated list, sorrounded
# by parenthesis or not, such that eval(s) is always a tuple
# - it strips, removes surrounding parthesis, and adds ',', unless it's
#   empty, in which case it returns '()'
# '(a,b)' -> 'a,b,'         '(a)' -> 'a,'      'a,b' -> 'a,b,'         
# '()'    -> '()'           ''    -> '()'
def makeArgString(s):
  s = s.strip()
  if (s[0] == '(' and s[-1] == ')'): s = s[1:-1]
  if (len(s) == 0): return '()'
  return s+','


# *** processing tags ***********************************************
def s(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags):
  return ''


def args(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags):
  # add the interface
  iset.add("ArityDefined");
  # parse arg
  inf = 'ArityDefined.INFINITE';
  if (len(tagArgs) == 0):minmax = ()
  else: minmax = eval(makeArgString(tagArgs));
  print minmax
  # if only one arg is defined, we set the second to the first
  if (len(minmax) == 1): minmax = minmax+minmax
  if (len(minmax) == 0): return ""
  return """
        public int getMaxNumOfArgs(){{ return {0}; }}
        public int getMinNumOfArgs(){{ return {1}; }}
        public boolean isVariadic(){{ return {0}=={1}; }}
""".format(*minmax)


