import sys
# in this file the code that gets generated by the tags gets printed
# the genBuiltin.py calls, for every encountered tag, a function with
# the same name in this module. The function will always be called
# with the same arguments, and should return string representing java
# code that will by inserted in the code for the Builtin where the tag
# occured. A tag has a name, and arguments. See the builtins.csv and
# genBuiltin.py
#
# functinos get called with the following arguments:
# (name, java-name, parent-java-name, is-abstract, tag-arguments(string), implements-set(string-set), tag-map)
def processTags(name, javaName, parentJavaName, isAbstract, iset, tags):
    code = "";
    for tagName in tags.keys():
       tagArgs = tags[tagName];
       # the function that deals with the tag needs to have the same name as the tag 
       f = eval(tagName)
       # calls with (name, java-name, parent-java-name, is-abstract, tag-arguments, implements-set, tag-map)
       code += f(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags)
    return code;

# *** Helper Functions **********************************************

# takes a string s which should be a comma separated list, sorrounded
# by parenthesis or not, such that eval(s) is always a tuple
# - it strips, removes surrounding parthesis, and adds ',', unless it's
#   empty, in which case it returns '()'
# '(a,b)' -> 'a,b,'         '(a)' -> 'a,'      'a,b' -> 'a,b,'         
# '()'    -> '()'           ''    -> '()'
def makeArgString(s):
  s = s.strip()
  if (s[0] == '(' and s[-1] == ')'): s = s[1:-1]
  if (len(s) == 0): return '()'
  return s+','


# *** processing tags ***********************************************
def s(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags):
  return ''


def args(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags):
  # add the interface
  iset.add("ArityDefined");
  # parse arg
  dict = {inf: 'ArityDefined.INFINITE'};
  if (len(tagArgs) == 0):minmax = ()
  else: minmax = eval(makeArgString(tagArgs),dict);
  print minmax
  # if only one arg is defined, we set the second to the first
  if (len(minmax) == 1): minmax = minmax+minmax
  if (len(minmax) == 0): return ""
  return """
        public int getMaxNumOfArgs(){{ return {0}; }}
        public int getMinNumOfArgs(){{ return {1}; }}
        public boolean isVariadic(){{ return {0}=={1}; }}
""".format(*minmax)

# coreces numbers to a MatlabClassVar
def coerceNum(a):          return MCNum(a) if isinstance(a, (long, int)) else a;
# general matlab class used by the class tag (MC = MatlabClass)
class MC():
  def __or__  (self, other): return MCUnion(coerceNum(self),coerceNum(other));
  def __ror__ (self, other): return MCUnion(coerceNum(self),coerceNum(other));
  def __and__ (self, other): return MCChain(coerceNum(self),coerceNum(other));
  def __rand__(self, other): return MCChain(coerceNum(self),coerceNum(other));
  def __gt__  (self, other): return MCMap(coerceNum(self),coerceNum(other));
  def __lt__  (self, other): return MCMap(coerceNum(other),coerceNum(self));
  def __repr__(self):        return str(self);
# class1 - represents Matlab builtin class
class MCBuiltin(MC):
  def __init__(self,name):   self.name = name;
  def __str__ (self):        return self.name;
  def toJava(self):          return 'new ClassPropTools.MCBuiltin("'+self.name+'")';
# class1 | clas2 - mulitple possibilities for one type
class MCUnion(MC):
  def __init__(self,a,b):    self.class1 = coerceNum(a); self.class2 = coerceNum(b);
  def __str__ (self):        return '('+str(self.class1)+'|'+str(self.class2)+')';
  def toJava(self):          return 'new ClassPropTools.MCUnion('+self.class1.toJava()+','+self.class2.toJava()+')';
# class1 & class2 - sequences of types
class MCChain(MC):
  def __init__(self,a,b):    self.class1 = coerceNum(a); self.class2 = coerceNum(b);
  def __str__ (self):        return '('+str(self.class1)+')&('+str(self.class2)+')';   
  def toJava(self):          return 'new ClassPropTools.MCChain('+self.class1.toJava()+','+self.class2.toJava()+')';
# class1 > class2 - matches argument and return types
class MCMap(MC):
  def __init__(self,a,b):    self.args = coerceNum(a); self.res = coerceNum(b);
  def __str__ (self):        return str(self.args)+'>'+str(self.res);   
  def toJava(self):          return 'new ClassPropTools.MCMap('+self.args.toJava()+','+self.res.toJava()+')';
# <n> - a specific other argument, defined by a number - negative is counted from back
class MCNum(MC):
  def __init__(self,num):    self.num = num;
  def __str__ (self):        return str(self.num);
  def toJava(self):          return 'new ClassPropTools.MCNum('+str(self.num)+')';
# coerce(list of argument MCBuiltin, target MCBuiltin, MC affeced expr)
# example: coerce([char,logical], double, (numerical&numerical)>double )
class MCCoerce(MC):
  def __init__(self,args,target,expr): self.args=args; self.target=target; self.expr=expr;
  def __str__(self):         return 'coerce('+str(self.args)+','+str(self.target)+','+str(self.expr)+')'
  def toJava(self):          return 'new ClassPropTools.MCCoerce(java.util.Arrays.asList('+','.join(map(MCBuiltin.toJava,self.args)) +\
                                    '),'+self.target.toJava()+','+self.expr.toJava()+')'
# none - matches anything without advancing, emits nothing
class MCNone(MC):
  def __str__ (self):        return str('none');
  def toJava(self):          return 'new ClassPropTools.MCNone()';
# parent - simply the tree of the parent
class MCParent(MC):
  def __str__ (self):        return str('parent');
  def toJava(self):          return 'getParentMatlabClassPropagationInfo()'; #calls the method to return parent tree



#none always matches, doesn't advance index
#var('x',class) # if x exists, tries ot match x, if it doesn't tries to match class and stores x in result?
#numericArgs(n,[max]]) # tries to match n numeric args, with int/single types having to be the same
#opt(x) # optional match (tries first to match it, then tries without matching it) - complexity x 2
#mult(x,[max],[min]) #tries to match as many as possible max,min may be 0
#ClassOfStringArg(n,class) # assumes argument n is a string denoting a class, one of class 

# turns a sequence of MC objects into MCUnion objects
def tupleToMC(seq):
  if len(seq) == 1: return seq[0]
  return MCUnion(seq[0],tupleToMC(seq[1:]))

def aclass(name, javaName, parentJavaName, isAbstract, tagArgs, iset, tags):
  # add the interface
  iset.add("ClassPropagationDefined");
  # set up names
  # arrays are multiple types: [double,int] is first a double, then an int
  # sequences are union types: (double,int) is either a double or an int - types are mached in order
  # basic types:
  lang = dict(double=MCBuiltin('double'), single=MCBuiltin('single'), char=MCBuiltin('char'), logical=MCBuiltin('logical'),
              uint8=MCBuiltin('int8'),uint16=MCBuiltin('uint16'),uint32=MCBuiltin('uint32'),uint64=MCBuiltin('uint64'),
              int8=MCBuiltin('int8'),int16=MCBuiltin('uint16'),int32=MCBuiltin('uint32'),int64=MCBuiltin('uint64'),
              function_handle=MCBuiltin('function_handle'))
  # union types
  lang.update(dict(float=lang['single']|lang['double'], uint=(lang['uint8']|lang['uint16']|lang['uint32']|lang['uint64']), 
                   sint=(lang['int8']|lang['int16']|lang['int32']|lang['int64'])));  
  lang['int']    = (lang['uint']|lang['sint']);
  lang['numeric']= (lang['float']|lang['int']);
  lang['matrix'] = (lang['numeric']|lang['char']|lang['logical']);
  # other bits of the language
  lang['none'] = MCNone();
  lang['coerce'] = lambda args, target, expr: MCCoerce(args,target,expr)
  lang['opt'] = lambda expr: (expr|lang['none']) #op(x) = (x|none) - will cause an error on the rhs
  lang['parent'] = MCParent();
  
  print
  print tagArgs
  # parse arg
  try:
      args = makeArgString(tagArgs);
      tree = eval(args,lang)
  except:
      sys.stderr.write("ERROR: cannot parse/build class propagation information for builtin: "+name+"\n");
      sys.stderr.write("def:   "+tagArgs+"\n");
      raise
  # turn tuple into chain of Unions
  if isinstance(tree, tuple): tree = tupleToMC(tree)
        
  print "tree: ", tree
  print "java: ", tree.toJava()

  return """
        private final ClassPropTools.MC classPropInfo = {tree};
        private ClassPropTools.MC parentClassPropInfo;
        
        //method that explicitly returns tree for 
        public final ClassPropTools.MC getMatlabClassPropInfoOf{javaName}(){{
            return this.classPropInfo;
        }}
        
        public ClassPropTools.MC getParentMatlabClassPropagationInfo(){{
            try{{
                //try to access the explicit tree method for the parent
                parentClassPropInfo = (ClassPropTools.MC)
                    getClass().getMethod("getMatlabClassPropInfoOf{parentJavaName}").invoke(this);
            }} catch (Exception e) {{ //on error, the parent does not provide the class prop info
                    parentClassPropInfo = new ClassPropTools.MCNone();
            }}
            return parentClassPropInfo;
        }}
        
        public ClassPropTools.MC getMatlabClassPropagationInfo(){{ return classPropInfo; }}
""".format(tree=tree.toJava(), javaName=javaName, parentJavaName=parentJavaName);



