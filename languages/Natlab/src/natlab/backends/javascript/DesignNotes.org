* Design Notes of the pretty printing library

The pretty printing library is a Java translation of how pretty
printers are usually represented in a functional language.  The pretty
printer representation is a tree, and we perform a depth-first
traversal through this tree to convert it to a string.  We have a
bunch of classes, so here is their hierarchy along with a quick
comment.

- *PrettyBase*: the abstract node type from which all concrete nodes inherit.
  - *PrettyLine*: a newline; we distinguish this node for indentation purposes.
  - *PrettyText*: a string of text; this text should not contain
    newline characters.
  - *PrettyIndent*: a node used to indicate that its descendents
    should be indented by one extra level.
  - *PrettyConcat*: a node with multiple children, represents the
    concatenation of all the children.
    - *PrettySeparatedBy*: concatenate nodes, separating them with a
      given string.
    - *PrettyWrapped*: a helper node, used to wrap a node between an
      opener and a closer.
      - *PrettyParenthesized*: wraps a node between parentheses.
      - *PrettyBracketed*: wraps a node between braces, separating
        inner elements with new lines.
- *Pair*: a combination of a node and an integer representing a level
  of indentation; used only with =PrettyUtils.display=.
- *PrettyUtils*: a collection of useful methods for nodes, including
  =display=, the library to convert from the pretty printer tree to a
  string representation.

** PrettyUtils.display

This method deserves its own, separate explanation.  We expose a
public =display= method that takes the root of the =PrettyBase= tree,
and make private the actual worker method.  The worker method takes 3
arguments:

- worklist: a stack of =<PrettyBase, int>= pairs, where the integer
  represents the indentation level of its associated node.
- sb: a StringBuffer that we use to efficiently accumulate the string
  output of the method.
- currCol: we need to maintain the column where text is to be written.
  This lets us know whether we need to insert a full indentation
  (i.e. currCol == 0), a partial indentation (i.e. currCol > 0 &&
  currCol < indentLevel*width), or no indentation (i.e. currCol >=
  indentLevel*width).

The method is a bit unidiomatic OO code with all the calls to
=instanceof=, however it is probably easier to implement this way
than through proper polymorphism.  The method works by popping a node
from the worklist (if there are any left).  If the node is a newline
or a text node, we simply add the text to the string buffer and
appropriately update the =currCol= value for the recursive call.

We process a =PrettyConcat= node by adding all its parts into the
stack.  We work through the parts backwards to make sure that the
first part will be the first one processed.  Note that this handling
of =PrettyConcat= also properly takes care of the derived classes,
such as =PrettyWrapped= and =PrettySeparatedBy=.

=PrettyIndent= is processed by taking its child and pushing it onto
the worklist with an increased indentation level.  If the child is an
inner node (e.g. =PrettyConcat=), further handling will propagate
this new indentation level to all descendents of =PrettyIndent=.
