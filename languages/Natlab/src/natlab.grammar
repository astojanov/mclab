%import "natlab.ast.*";

%package "natlab";

%class "NatlabParser";

%embed {:
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    { report = new Events(); } // Use error handler in parser
    
    private static <T extends ASTNode<?>> natlab.ast.List<T> addAll(natlab.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    private static <T extends ASTNode<?>> natlab.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new natlab.ast.List<T>(), children);
    }

    //need this because non-terminals must return symbols
    private static class BooleanFakeSymbol extends Symbol {
        private boolean value;
        BooleanFakeSymbol(boolean value) { this.value = value; }
        Stmt annotateStmt(Stmt stmt) { stmt.setOutputSuppressed(value); return stmt; }
    }
    
    private CommentBuffer commentBuffer = null;

    public void setCommentBuffer(CommentBuffer commentBuffer) {
        this.commentBuffer = commentBuffer;
    }

    public CommentBuffer getCommentBuffer() {
        return commentBuffer;
    }
    
    private <T extends ASTNode> T annotateWithComments(T node) {
        if(node != null && commentBuffer != null) {
            node.setComments(commentBuffer.pollAllComments());
        }
        return node;
    }
:};

%terminals IDENTIFIER;
%terminals INT_NUMBER, FP_NUMBER, IM_INT_NUMBER, IM_FP_NUMBER;
%terminals COMMENT, HELP_COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT, BRACKET_HELP_COMMENT, SHELL_COMMAND;
%terminals LPAREN, RPAREN, LSQUARE, RSQUARE, LCURLY, RCURLY;
%terminals BREAK, CASE, CATCH, CLASSDEF, CONTINUE, ELSE, ELSEIF, END, FOR, FUNCTION, GLOBAL, IF, OTHERWISE, PARFOR, PERSISTENT, RETURN, SWITCH, TRY, WHILE;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR, ASSIGN;
%terminals DOT, COMMA, SEMICOLON, LINE_TERMINATOR, COMMA_LINE_TERMINATOR, SEMICOLON_LINE_TERMINATOR;
%terminals COLON, AT;
%terminals STRING;
%terminals PROPERTIES, METHODS, EVENTS;

%typeof program, program_before_comments = "Program";
%typeof script = "Script";
%typeof class_def = "ClassDef";
%typeof stmt_list = "List<Stmt>";
%typeof stmt, stmt_body, last_stmt, stmt_body_before_comments = "Stmt";
%typeof for_assign, assign = "AssignStmt";
%typeof expr, binary_expr, colon_expr, prefix_expr, postfix_expr, pow_expr, primary_expr = "Expr";
%typeof lvalue = "Access";
%typeof arg_list = "List<Expr>";
%typeof arg = "Expr";
%typeof matrix = "MatrixDecl";
%typeof row_list, optional_row_list = "List<MatrixRow>";
%typeof row = "MatrixRow";
%typeof literal = "Literal";
%typeof name, simple_name = "ParseName";
%typeof stmt_separator = "BooleanFakeSymbol";
%typeof help_comment, help_comment_body, last_help_comment = "HelpComment";

%typeof IDENTIFIER, COMMENT, HELP_COMMENT, STRING = "String";
%typeof INT_NUMBER, IM_INT_NUMBER = "IntNumericLiteralValue";
%typeof FP_NUMBER, IM_FP_NUMBER = "FPNumericLiteralValue";

// Precedence and associativity.
//NB: everything seems to be left associative in matlab (even pow and ldiv)
%left MPOW, EPOW;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND;
%left OR;
%left SHORTAND;
%left SHORTOR;

%goal program;

program =
     //gather up any unclaimed comments
     program_before_comments.p {: return annotateWithComments(p); :}
  ;

// Currently, a .m file is treated as a list of statements.
program_before_comments = 
     script.s
  |  class_def.c
  |  {: return new EmptyProgram(); :}
  |  OtherNonTerm {: return new EmptyProgram(); :} //TODO-AC: eventually remove this
  ;

//NB: must be non-empty to avoid conflicting with EmptyProgram case above
script =
     //NB: can't use a stmt_list here - it causes a bunch of warnings (not sure why)
     stmt.stmts+ last_stmt.s {: return new Script(new List<HelpComment>(), makeListNode(_list_stmts).add(s)); :}
  |  last_stmt.s {: return new Script(new List<HelpComment>(), new List<Stmt>().add(s)); :}
  |  help_comment.comments+ stmt.stmts+ last_stmt.s {: return new Script(makeListNode(_list_comments), makeListNode(_list_stmts).add(s)); :}
  |  help_comment.comments+ last_stmt.s {: return new Script(makeListNode(_list_comments), new List<Stmt>().add(s)); :}
  |  help_comment.comments+ last_help_comment.c {: return new Script(makeListNode(_list_comments).add(c), new List<Stmt>()); :}
  |  last_help_comment.c {: return new Script(new List<HelpComment>().add(c), new List<Stmt>()); :}
  ;

//NB: must be non-empty to avoid conflicting with EmptyProgram case above
class_def = //TODO-AC: fill in
     CLASSDEF END {: return new ClassDef(); :}
  ;

last_help_comment =
     help_comment.c
  |  help_comment_body.c
  ;

help_comment =
     help_comment_body.c LINE_TERMINATOR
  ;

help_comment_body =
     HELP_COMMENT.c {: return new OneLineHelpComment(c); :}
  |  BRACKET_HELP_COMMENT.c {: return new MultiLineHelpComment(c); :}
  ;

stmt_list =
     stmt.stmts+ {: return makeListNode(_list_stmts); :}
  |  {: return new List<Stmt>(); :}
  ;

last_stmt =
     stmt_body.s
  |  stmt.s
  ;

stmt =
     stmt_body.s stmt_separator.sep {: return sep.annotateStmt(s); :}
     //NB: not attaching comments to empty statements
  |  stmt_separator.sep {: return sep.annotateStmt(new EmptyStmt()); :} //TODO-AC: do we really need this in the AST
  ;

stmt_body =
     stmt_body_before_comments.s {: return annotateWithComments(s); :}
  ;

stmt_body_before_comments =
     expr.e {: return new ExprStmt(e); :}
  |  assign.a
//  |  if_then_statement
//  |  if_then_else_statement
//  |  switch_statement
//  |  try_statement
  |  BREAK    {: return new BreakStmt(); :}
  |  CONTINUE {: return new ContinueStmt(); :}
  |  WHILE expr.e stmt_separator stmt_list.l END {: return new WhileStmt(e, l); :}
  |  FOR for_assign.a stmt_separator stmt_list.l END {: return new ForStmt(a, l); :}
  ;

stmt_separator =
     LINE_TERMINATOR {: return new BooleanFakeSymbol(false); :}
  |  SEMICOLON {: return new BooleanFakeSymbol(true); :}
  |  SEMICOLON_LINE_TERMINATOR {: return new BooleanFakeSymbol(true); :}
  |  COMMA {: return new BooleanFakeSymbol(false); :}
  |  COMMA_LINE_TERMINATOR {: return new BooleanFakeSymbol(false); :}
  ;

for_assign =
     assign.a
  |  LPAREN assign.a RPAREN
  ;

assign =
     lvalue.lhs ASSIGN expr.rhs {: return new AssignStmt(lhs, rhs); :}
  ;

lvalue =
     name.id
  |  access.a
  ;

access =
     name.n LPAREN RPAREN
     {:
         ParseName pn = (ParseName) n;
         return new ParameterizedAccess(pn.getID(), new List());
     :}
  |  name.n LPAREN arg_list.l RPAREN
     {:
         ParseName pn = (ParseName) n;
         return new ParameterizedAccess(pn.getID(), l);
     :}
  ;

name =
     simple_name.n
  ;

simple_name =
     IDENTIFIER.id {: return new ParseName(id); :}
  ;

//precedence from: http://www.mathworks.com/access/helpdesk/help/techdoc/matlab_prog/f0-40063.html
expr =
     colon_expr.e
  |  expr.e1 LT expr.e2 {: return new LTExpr(e1, e2); :}
  |  expr.e1 GT expr.e2 {: return new GTExpr(e1, e2); :}
  |  expr.e1 LE expr.e2 {: return new LEExpr(e1, e2); :}
  |  expr.e1 GE expr.e2 {: return new GEExpr(e1, e2); :}
  |  expr.e1 EQ expr.e2 {: return new EQExpr(e1, e2); :}
  |  expr.e1 NE expr.e2 {: return new NEExpr(e1, e2); :}
  |  expr.e1 AND expr.e2 {: return new AndLogicalExpr(e1, e2); :}
  |  expr.e1 OR expr.e2 {: return new OrLogicalExpr(e1, e2); :}
  |  expr.e1 SHORTAND expr.e2 {: return new ShortCircuitAndExpr(e1, e2); :}
  |  expr.e1 SHORTOR expr.e2 {: return new ShortCircuitOrExpr(e1, e2); :}
  ;

colon_expr =
     binary_expr.e
  |  binary_expr.e1 COLON binary_expr.e3 {: return new ColonExpr(e1, new Opt(), e3); :}
  |  binary_expr.e1 COLON binary_expr.e2 COLON binary_expr.e3 {: return new ColonExpr(e1, new Opt(e2), e3); :}
  ;

binary_expr =
     prefix_expr.e
  |  binary_expr.e1 MTIMES binary_expr.e2  {: return new MulExpr(e1, e2); :}
  |  binary_expr.e1 ETIMES binary_expr.e2  {: return new EMulExpr(e1, e2); :}
  |  binary_expr.e1 MDIV binary_expr.e2    {: return new DivExpr(e1, e2); :}
  |  binary_expr.e1 EDIV binary_expr.e2    {: return new EDivExpr(e1, e2); :}
  |  binary_expr.e1 MLDIV binary_expr.e2   {: return new LeftDivExpr(e1, e2); :}
  |  binary_expr.e1 ELDIV binary_expr.e2   {: return new ELeftDivExpr(e1, e2); :}
  |  binary_expr.e1 PLUS binary_expr.e2    {: return new AddExpr(e1, e2); :}
  |  binary_expr.e1 MINUS binary_expr.e2   {: return new SubExpr(e1, e2); :}
  ;

prefix_expr =
     pow_expr.e
  |  NOT prefix_expr.e {: return new LogNotExpr(e); :}
  |  PLUS prefix_expr.e {: return new PlusExpr(e); :}
  |  MINUS prefix_expr.e {: return new MinusExpr(e); :}
  ;

pow_expr =
     postfix_expr.e
  |  pow_expr.e1 MPOW pow_expr.e2    {: return new PowExpr(e1, e2); :}
  |  pow_expr.e1 EPOW pow_expr.e2    {: return new EPowExpr(e1, e2); :}
  ;

postfix_expr =
     primary_expr.e
  |  postfix_expr.e ARRAYTRANSPOSE {: return new ArrayTransposeExpr(e); :}
  |  postfix_expr.e MTRANSPOSE {: return new TransposeExpr(e); :}
  ;

primary_expr =
     literal.l
  |  LPAREN expr.e RPAREN
  |  matrix.m
  |  access.a
//  |  AT name.n //TODO-AC: return handle node 
  |  name.n
  ;

literal =
     INT_NUMBER.i {: return new IntegerLiteral(i); :}
  |  FP_NUMBER.f {: return new DoubleLiteral(f); :}
  |  STRING.s {: return new StringLiteral(s); :}
  ;

matrix =
     LSQUARE optional_row_list.l RSQUARE {: return new MatrixDecl(l); :}
  ;

optional_row_list =
     {: return new List<MatrixRow>(); :}
  |  row_separator {: return new List<MatrixRow>(); :}
  |  row_list.l {: return l; :}
  |  row_list.l row_separator {: return l; :}
  ;

row_list =
     row.r {: return new List<MatrixRow>().add(r); :}
  |  row_list.l row_separator row.r {: return l.add(r); :}
  ;

row =
     arg_list.l COMMA? {: return new MatrixRow(l); :}
  ;

row_separator =
     LINE_TERMINATOR
  |  SEMICOLON
  |  SEMICOLON_LINE_TERMINATOR
  |  COMMA_LINE_TERMINATOR 
  ;

arg_list =
     arg.a {: return new List<Expr>().add(a); :}
  |  arg_list.l COMMA arg.a {: return l.add(a); :}
  ;
  
arg =
     expr.e
  |  COLON.c {: return new Colon(); :}
  ;

OtherNonTerm =
    IM_INT_NUMBER
  | IM_FP_NUMBER
  | LCURLY
  | RCURLY
//  | BREAK
  | CASE
  | CATCH
//  | CONTINUE
  | ELSE
  | ELSEIF
  | FUNCTION
  | GLOBAL
  | IF
  | OTHERWISE
  | RETURN
  | PARFOR
  | PERSISTENT
  | SWITCH
  | TRY
//  | WHILE
  | SHELL_COMMAND
  | ELLIPSIS_COMMENT
  | DOT
  | PROPERTIES
  | METHODS
  | EVENTS
  | COMMENT
  | BRACKET_COMMENT
  | AT
  ;
