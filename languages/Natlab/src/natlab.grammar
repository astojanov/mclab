%import "natlab.ast.*";
%import "java.util.Collections";
%import "java.util.Iterator";
%import "java.util.List";

%package "natlab";

%class "NatlabParser";

%embed {:
    private final List<String> errors = new ArrayList<String>();

    public List<String> getErrors() {
        return Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line, e.column) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    { report = new Events(); } // Use error handler in parser
:};

%terminals IDENTIFIER, LAMBDA, ARG_BODY_SEP, LPAREN, RPAREN;
%typeof IDENTIFIER = "String";
%typeof Abs = "MultiAbs";
%typeof Var = "Var";
%typeof App, Base, Parens = "Node";

%goal Start;

Start
  = App.app {: return new Root(app); :}
  ;

App
  = Base.others+ Abs.abs? {:
        List<Node> nodes = new ArrayList<Node>(_list_others);
        if(abs != null) {
            nodes.add(abs);
        }
        Iterator<Node> it = nodes.iterator();
        Node curr = it.next();
        while(it.hasNext()) {
            curr = new App(curr, it.next());
        }
        return curr;
    :}
  | Abs //returns what the abs returns
  ;

Abs
  = LAMBDA Var.vars+ ARG_BODY_SEP App.body {:
        //NB: could easily de-sugar here (as in App, but this lets us test rewriting)
        natlab.ast.List<Var> allVars = new natlab.ast.List<Var>();
        for(Var var : vars) {
            allVars.add(var);
        } 
        return new MultiAbs(allVars, body);
    :}
  ;

Base
  = Parens //returns what the parens returns
  | Var    //returns what the var returns
  ;

Parens
  = LPAREN App.app RPAREN //returns what the nested app returns
  ;

Var
  = IDENTIFIER.var {: return new Var(var); :}
  ;