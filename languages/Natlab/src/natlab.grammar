%import "natlab.ast.*";
// %import "java.util.Collections";
%import "java.util.Iterator";
// %import "java.util.List";

%package "natlab";

%class "NatlabParser";

%embed {:
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    { report = new Events(); } // Use error handler in parser
:};

%terminals IDENTIFIER;
%terminals INT_NUMBER, FP_NUMBER, IM_INT_NUMBER, IM_FP_NUMBER;
%terminals COMMENT, HELP_COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT, BRACKET_HELP_COMMENT, SHELL_COMMAND;
%terminals LPAREN, RPAREN, LSQUARE, RSQUARE, LCURLY, RCURLY;
%terminals BREAK, CASE, CATCH, CLASSDEF, CONTINUE, ELSE, ELSEIF, END, FOR, FUNCTION, GLOBAL, IF, OTHERWISE, PARFOR, PERSISTENT, RETURN, SWITCH, TRY, WHILE;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR, ASSIGN;
%terminals LINE_TERMINATOR;
%terminals DOT, COMMA, SEMICOLON;
%terminals COLON, AT;
%terminals STRING;
%terminals PROPERTIES, METHODS, EVENTS;

/****************************************************************

%typeof IDENTIFIER, COMMENT, HELP_COMMENT, STRING = "String";
%typeof INT_NUMBER, IM_INT_NUMBER = "IntNumericLiteralValue";
%typeof FP_NUMBER, IM_FP_NUMBER = "FPNumericLiteralValue";

%typeof Start  = "List";
%typeof NonTerm  = "ASTNode";

%goal Start;

Start
  = NonTerm+
  ;

NonTerm
  = IDENTIFIER
  | INT_NUMBER
  | FP_NUMBER
  | IM_INT_NUMBER
  | IM_FP_NUMBER
  | LPAREN
  | RPAREN
  | LSQUARE
  | RSQUARE
  | LCURLY
  | RCURLY
  | BREAK
  | CASE
  | CATCH
  | CONTINUE
  | ELSE
  | ELSEIF
  | END
  | FOR
  | FUNCTION
  | GLOBAL
  | IF
  | OTHERWISE
  | RETURN
  | PERSISTENT
  | SWITCH
  | TRY
  | WHILE
  | LINE_TERMINATOR
  | COMMENT
  | HELP_COMMENT
  | DOT
  | COMMA
  | SEMICOLON
  | COLON
  | PLUS
  | MINUS
  | MTIMES
  | ETIMES
  | MDIV
  | EDIV
  | MLDIV
  | ELDIV
  | MPOW
  | EPOW
  | MTRANSPOSE
  | ARRAYTRANSPOSE
  | LE
  | GE
  | LT
  | GT
  | EQ
  | NE
  | AND
  | OR
  | NOT
  | SHORTAND
  | SHORTOR
  | AT
  | STRING
  | SHELL_COMMAND
  | ELLIPSIS_COMMENT
  | BRACKET_COMMENT
  | ASSIGN
  ;
********************************************************************/

//===================================================================
// Starting from here, a copy from matrix.gramm to natlab.grammar
//===================================================================

// Precedence and associativity.
%left MPOW, EPOW, ARRAYTRANSPOSE;
%left NOT;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND, SHORTAND;
%left OR, SHORTOR;

%typeof program = "Root";
%typeof statement_list = "List";
%typeof statement = "Stmt";
%typeof expression = "Expr";
%typeof empty_statement = "EmptyStmt";
%typeof expression_statement = "ExprStmt";
%typeof literal = "Literal";
%typeof name, simple_name = "ParseName";
%typeof simple_expression= "Expr";
%typeof assignment = "AssignExpr";			 
%typeof left_hand_side = "Access";
%typeof primary_expression = "Expr";
%typeof argument_list = "List";
%typeof method_invocation = "Access";
%typeof matrix_access = "Access";
%typeof matrix = "Access";
%typeof maxtrix_rows = "List";
%typeof cell_or_matrix_row = "MatrixRow";
%typeof colon_expression, binary_expression, prefix_expression, postfix_expression= "Expr";

%typeof NonTerm = "EmptyStmt";

%typeof IDENTIFIER, COMMENT, HELP_COMMENT, STRING = "String";
%typeof INT_NUMBER, IM_INT_NUMBER = "IntNumericLiteralValue";
%typeof FP_NUMBER, IM_FP_NUMBER = "FPNumericLiteralValue";

%goal program;

// Currently, a .m file is treated as a list of statements.
program = statement_list.stmtlist      {: return new Root(stmtlist); :}
  ;
statement_list =
     statement.stmt                    {: return new List().add(stmt); :}
  |  statement_list.sl statement.stmt  {: return sl.add(stmt); :}
  ;

statement =
     empty_statement.s              {: return s; :}
  |  expression_statement.s         {: return s; :}
/*  // those statement could be here ...
  |  if_then_statement
  |  if_then_else_statement
  |  while_statement
  |  switch_statement
  |  do_statement
  |  break_statement
  |  continue_statement
  |  try_statement
*/
  |  FOR LPAREN? assignment.a RPAREN? statement_separator program.p END
  						  {: return new ForStmt(a, p); :}	
  ;

empty_statement =
     statement_separator  {: return new EmptyStmt(""); :}
  |  COMMENT.str          {: return new CommentStmt(str); :}
  |  HELP_COMMENT.str     {: return new CommentStmt(str); :}
  |  BRACKET_COMMENT.str  {: return new CommentStmt(str); :}
  |  BRACKET_HELP_COMMENT.str  {: return new CommentStmt(str); :}
//----------------------------------------------------------------->>
// Unsupport tokens in current version
  |  NonTerm+             {: return new EmptyStmt(""); :}
  ;

NonTerm
  =
    IM_INT_NUMBER
  | IM_FP_NUMBER
  | LCURLY
  | RCURLY
  | BREAK
  | CASE
  | CATCH
  | CLASSDEF
  | CONTINUE
  | ELSE
  | ELSEIF
  | FUNCTION
  | GLOBAL
  | IF
  | OTHERWISE
  | RETURN
  | PARFOR
  | PERSISTENT
  | SWITCH
  | TRY
  | WHILE
  | SHELL_COMMAND
  | ELLIPSIS_COMMENT
  | DOT
  | PROPERTIES
  | METHODS
  | EVENTS
  ;
//-----------------------------------------------------------------<<

expression_statement =
     expression.e statement_separator          {: return new ExprStmt(e); :}
  ;

statement_separator =
     LINE_TERMINATOR
  |  SEMICOLON LINE_TERMINATOR?
  |  COMMA LINE_TERMINATOR?
  ;

// Lexical Structure.
literal =    INT_NUMBER.i  {: return new IntegerLiteral(i); :}
  |  FP_NUMBER.f           {: return new DoubleLiteral(f); :}
  |  STRING.s              {: return new StringLiteral(s); :}
//  |  BOOLEAN_LITERAL.b     {: return new BooleanLiteral(b); :}
  ;

//  Names
name    =    simple_name
  ;
simple_name =    IDENTIFIER.id          {: return new ParseName(id); :}
  ;

// Matrix
matrix =
     LSQUARE maxtrix_rows.l SEMICOLON RSQUARE    {: return new MatrixDecl(l); :}
  |  LSQUARE maxtrix_rows.l RSQUARE     {: return new MatrixDecl(l); :}
  |  LSQUARE SEMICOLON RSQUARE          {: return new MatrixDecl(new List()); :}
  |  LSQUARE RSQUARE                    {: return new MatrixDecl(new List()); :}
  ;

maxtrix_rows =
     cell_or_matrix_row.row             {: return new List().add(row); :}
  |  maxtrix_rows.l SEMICOLON cell_or_matrix_row.row   {: return l.add(row); :}
  ;

cell_or_matrix_row =
     argument_list.l            {: return new MatrixRow(l); :}
  |  argument_list.l COMMA      {: return new MatrixRow(l); :}
  ;

// Expressions
primary_expression =
     literal.l                  {: return l; :}
  |  LPAREN expression.e RPAREN     {: return new ParExpr(e); :}
  |  matrix.m                   {: return m; :}
  |  method_invocation.m        {: return m; :}
  |  AT name.n                  {: return n; :}
  ;

// Adding ':' for MATLAB matrix-access
// There is ambiguous that allows foo(:), if foo() is an function,
// and A() if A is matrix.
argument_list =
     expression.e                        {: return new List().add(e); :}
  |  argument_list.l COMMA expression.e  {: return l.add(e); :}
  |  COLON.c                             {: return new List().add(new Colon(":")); :}
  |  argument_list.l COMMA COLON.c       {: return l.add(new Colon(":")); :}
  ;

method_invocation =
     name.n LPAREN RPAREN
     {:
         ParseName pn = (ParseName)n;
         return new MethodAccess(pn.getID(), new List());
     :}
  |  name.n LPAREN argument_list.l RPAREN
     {:
         ParseName pn = (ParseName)n;
         return new MethodAccess(pn.getID(), l);
     :}
  ;
// Matrix accesss
matrix_access =
     name.n LPAREN argument_list.l RPAREN
     {:
         ParseName pn = (ParseName)n;
         return new MatrixAccess(pn.getID(), l);
     :}
  ;

postfix_expression =
     primary_expression.e       {: return e; :}
  |  name.n                     {: return n; :}
  |  postfix_expression.e ARRAYTRANSPOSE  {: return new TransposeExpr(e); :}
  |  postfix_expression.e MTRANSPOSE      {: return new TransposeExpr(e); :}
  ;
prefix_expression =
     postfix_expression.e       {: return e; :}
  |  binary_expression.e        {: return e; :}
  |  NOT prefix_expression.e    {: return new LogNotExpr(e); :}
  |  PLUS prefix_expression.e   {: return new PlusExpr(e); :}
  |  MINUS prefix_expression.e  {: return new MinusExpr(e); :}
  ;
binary_expression =
     prefix_expression.e1 MPOW prefix_expression.e2    {: return new PowExpr(e1, e2); :}
  |  prefix_expression.e1 EPOW prefix_expression.e2    {: return new EPowExpr(e1, e2); :}
  |  prefix_expression.e1 MTIMES prefix_expression.e2  {: return new MulExpr(e1, e2); :}
  |  prefix_expression.e1 MDIV prefix_expression.e2    {: return new DivExpr(e1, e2); :}
  |  prefix_expression.e1 ETIMES prefix_expression.e2  {: return new EMulExpr(e1, e2); :}
  |  prefix_expression.e1 EDIV prefix_expression.e2    {: return new EDivExpr(e1, e2); :}
  |  prefix_expression.e1 MLDIV prefix_expression.e2   {: return new LeftDivExpr(e1, e2); :}
  |  prefix_expression.e1 ELDIV prefix_expression.e2   {: return new ELeftDivExpr(e1, e2); :}
  |  prefix_expression.e1 PLUS prefix_expression.e2    {: return new AddExpr(e1, e2); :}
  |  prefix_expression.e1 MINUS prefix_expression.e2   {: return new SubExpr(e1, e2); :}
  ;
// Colon expression for MATLAB -JL
colon_expression =
     prefix_expression.e        {: return e; :}
  |  prefix_expression.e1 COLON prefix_expression.e3   {: return new ColonExpr(e1, new Opt(), e3); :}
  |  prefix_expression.e1 COLON prefix_expression.e2 COLON prefix_expression.e3
              {: return new ColonExpr(e1, new Opt(e2), e3); :}
  ;
simple_expression =
     colon_expression
  |  simple_expression.e1 LT simple_expression.e2       {: return new LTExpr(e1, e2); :}
  |  simple_expression.e1 GT simple_expression.e2       {: return new GTExpr(e1, e2); :}
  |  simple_expression.e1 LE simple_expression.e2       {: return new LEExpr(e1, e2); :}
  |  simple_expression.e1 GE simple_expression.e2       {: return new GEExpr(e1, e2); :}
  |  simple_expression.e1 EQ simple_expression.e2       {: return new EQExpr(e1, e2); :}
  |  simple_expression.e1 NE simple_expression.e2       {: return new NEExpr(e1, e2); :}
  |  simple_expression.e1 AND simple_expression.e2      {: return new AndLogicalExpr(e1, e2); :}
  |  simple_expression.e1 OR simple_expression.e2       {: return new OrLogicalExpr(e1, e2); :}
  |  simple_expression.e1 SHORTAND simple_expression.e2    {: return new AndLogicalExpr(e1, e2); :}
  |  simple_expression.e1 SHORTOR simple_expression.e2     {: return new OrLogicalExpr(e1, e2); :}
  ;

assignment =
    left_hand_side.dest ASSIGN expression.source {: return new AssignSimpleExpr(dest, source); :}
  ;

// Adding matrix_access
left_hand_side =
     name.id                    {: return id; :}
  |  matrix_access.m            {: return m; :}
  ;

expression =
     simple_expression.e        {: return e; :}
  |  assignment.a               {: return a; :}
  ;
