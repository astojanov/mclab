// AST for Natlab grammar

abstract Program;

Script : Program ::= HelpComment* Stmt*;
FunctionList : Program ::= Function*;
ClassDef : Program; //TODO-AC: contents
EmptyProgram : Program;

Function ::= OutputParam:Param* <Name:String> InputParam:Param* HelpComment* Stmt* NestedFunction:Function*;
Param : ParseName; //TODO-AC: is this the correct parent type?

abstract HelpComment ::= <Text:String>;
OneLineHelpComment : HelpComment;
MultiLineHelpComment : HelpComment;

abstract Stmt; 
EmptyStmt:Stmt;
ExprStmt:Stmt ::= Expr;
AssignStmt:Stmt ::= Dest:Expr Source:Expr;
GlobalStmt : Stmt ::= Name:ParseName*;
PersistentStmt : Stmt ::= Name:ParseName*;
ShellCommandStmt : Stmt ::= <Command : String>;

abstract Expr;

ColonExpr:Expr ::= Base:Expr [Incr:Expr] Limit:Expr;
Colon:Expr;

abstract Access:Expr;

// LHS of assignments
IdUse:Access ::= <ID:String>;
ParseName:Access ::= <ID:String>;

ParameterizedAccess : Access ::= <ID:String> Arg:Expr*;

abstract CellContentAccess:Access;
SingleCellContentAccess : CellContentAccess ::= <ID:String> Arg:Expr*;
MultiCellContentAccess : CellContentAccess ::= CellContentAccess Arg:Expr*;
CellIndexAccess : Access ::= CellContentAccess Arg:Expr*;

MatrixDecl : Access ::= Row*;
CellArrayDecl : Access ::= Row*;
Row : Access ::= Element:Expr*;

// VarAccess : Access ::= <ID:String>;

// Other expressions 
abstract PrimaryExpr : Expr;

ParExpr : PrimaryExpr ::= Expr;

abstract Literal : PrimaryExpr;
IntegerLiteral : Literal ::= <Value:natlab.IntNumericLiteralValue>;
DoubleLiteral : Literal ::= <Value:natlab.FPNumericLiteralValue>;
StringLiteral : Literal ::= <Value:String>;

//-------------------------------------------------------------------
abstract Unary : Expr ::= Operand:Expr;
MinusExpr : Unary ;
PlusExpr : Unary ;
LogNotExpr : Unary ;
TransposeExpr : Unary ;
ArrayTransposeExpr : Unary ;

abstract Binary : Expr ::= LeftOperand:Expr RightOperand:Expr;

abstract ArithmeticExpr : Binary;
abstract MultiplicativeExpr : ArithmeticExpr;
MulExpr : MultiplicativeExpr ;
DivExpr : MultiplicativeExpr ;
LeftDivExpr : MultiplicativeExpr ;
PowExpr : MultiplicativeExpr ;

abstract AdditiveExpr : ArithmeticExpr;
AddExpr : AdditiveExpr ;
SubExpr : AdditiveExpr ;

// Element wise expression
abstract EMultiplicativeExpr : ArithmeticExpr;
EMulExpr : EMultiplicativeExpr ;
EDivExpr : EMultiplicativeExpr ;
ELeftDivExpr : EMultiplicativeExpr ;
EPowExpr : EMultiplicativeExpr ;

abstract LogicalExpr : Binary;
AndLogicalExpr : LogicalExpr ;
OrLogicalExpr : LogicalExpr ;

abstract ShortCircuitExpr : Binary;
ShortCircuitAndExpr : ShortCircuitExpr ;
ShortCircuitOrExpr : ShortCircuitExpr ;

abstract RelationalExpr : Binary;
LTExpr : RelationalExpr ;
GTExpr : RelationalExpr ;
LEExpr : RelationalExpr ;
GEExpr : RelationalExpr ;

abstract EqualityExpr : RelationalExpr;
EQExpr : EqualityExpr ;
NEExpr : EqualityExpr ;

FunctionHandle : Expr ::= <Name : String>;
LambdaDef : Expr ::= InputParam:Param* Body:Expr;

//------- ------------------------------------------------------------
// statement that can be reached by break or continue
abstract BranchTargetStmt : Stmt;  
ForStmt : BranchTargetStmt ::= AssignStmt Stmt*; 
WhileStmt : BranchTargetStmt ::= Expr Stmt*; 
SwitchStmt : BranchTargetStmt ::= Expr SwithCase* [DefaultCase];
abstract Case : Stmt;
SwithCase : Case ::= Expr Stmt*;
DefaultCase : Case  ::= Stmt*;

BreakStmt : Stmt;
ContinueStmt : Stmt;
ReturnStmt : Stmt;

IfStmt : Stmt ::= Condition:Expr Then:Stmt* Elseif:ElseifStmt* [Else:List];
ElseifStmt : Stmt ::= Condition:Expr Then:Stmt*;

TryStmt : Stmt ::= TryBlock:Stmt* CatchBlock:Stmt*;

