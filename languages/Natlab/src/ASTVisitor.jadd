/*
 * This aspect is intend to adapt the ASTNode to support flow analysis interface
 *  1. Adjust the ASTNode to implement Unit interface
 *  1. Adding corresponding functions for Visitor pattern  
 */
import java.util.*;

aspect ASTVisitor {

    // ASTNode implements Unit interface
    // declare parents: ASTNode implements natlab.toolkits.Unit; 
    ASTNode implements natlab.toolkits.Unit; 

    
    // Default implementation for the Unit interface ... 
    // Took from AbstractUnit.java
    /** Returns a list of Boxes containing Values used in this Unit.
     * The list of boxes is dynamically updated as the structure changes.
     * Note that they are returned in usual evaluation order.
     * (this is important for aggregation)
     */
    public java.util.List ASTNode.getUseBoxes()
    {
    	if((valueBoxes == null) || valueBoxes.isEmpty())
        	return emptyList;
        else
        	return valueBoxes;
    }

    /** Returns a list of Boxes containing Values defined in this Unit.
     * The list of boxes is dynamically updated as the structure changes.
     */
    public java.util.List ASTNode.getDefBoxes()
    {
        return emptyList;
    }


    /** Returns a list of Boxes containing Units defined in this Unit; typically
     * branch targets.
     * The list of boxes is dynamically updated as the structure changes.
     */
    public java.util.List ASTNode.getUnitBoxes()
    {
        return emptyList;
    }

    /** Canonical AbstractUnit.emptyList list. */
    static final public java.util.List ASTNode.emptyList = java.util.Collections.EMPTY_LIST;

    /** java.util.List of natlab.toolkits.UnitBoxes pointing to this Unit. */
    java.util.List ASTNode.boxesPointingToThis = null;

    /** java.util.List of ValueBoxes contained in this Unit. */
    java.util.List ASTNode.valueBoxes = new java.util.ArrayList();

    /** Returns a list of Boxes pointing to this Unit. */
    public java.util.List ASTNode.getBoxesPointingToThis()
    {
        if( boxesPointingToThis == null ) return emptyList;
        return java.util.Collections.unmodifiableList( boxesPointingToThis );
    }

    public void ASTNode.addBoxPointingToThis( natlab.toolkits.UnitBox b ) {
        if( boxesPointingToThis == null ) boxesPointingToThis = new ArrayList();
        boxesPointingToThis.add( b );
    }

    public void ASTNode.removeBoxPointingToThis( natlab.toolkits.UnitBox b ) {
        if( boxesPointingToThis != null ) boxesPointingToThis.remove( b );
    }

    public void ASTNode.clearUnitBoxes() {
        for( Iterator it = getUnitBoxes().iterator(); it.hasNext(); ) {
            natlab.toolkits.UnitBox ub = (natlab.toolkits.UnitBox) it.next();
            ub.setUnit(null);
        }
    }
    
    /** Returns a list of ValueBoxes, either used or defined in this Unit. */
    public java.util.List ASTNode.getUseAndDefBoxes()
    {
        java.util.List useBoxes = getUseBoxes();
        java.util.List defBoxes = getDefBoxes();
        if( useBoxes.isEmpty() ) {
            if( defBoxes.isEmpty() ) {
                return emptyList;
            } else {
                return java.util.Collections.unmodifiableList(defBoxes);
            }
        } else {
            if( defBoxes.isEmpty() ) {
                return java.util.Collections.unmodifiableList(useBoxes);
            } else {
                valueBoxes = new ArrayList();

                valueBoxes.addAll(defBoxes);
                valueBoxes.addAll(useBoxes);

                valueBoxes = java.util.Collections.unmodifiableList(valueBoxes);

                return valueBoxes;
            }
        }
    }

    public void ASTNode.redirectJumpsToThisTo(natlab.toolkits.Unit newLocation)
    {
        java.util.List boxesPointing = this.getBoxesPointingToThis();

        Object[] boxes = boxesPointing.toArray();
        // important to change this to an array to have a static copy
        
        for (Object element : boxes) {
            natlab.toolkits.UnitBox box = (natlab.toolkits.UnitBox) element;

            if(box.getUnit() != this)
                throw new RuntimeException("Something weird's happening");

            if(box.isBranchTarget())
                box.setUnit(newLocation);
        }

    }
    
    
    /** Returns true if execution after this statement may continue at the following statement.
     * GotoStmt will return false but IfStmt will return true. */
    public boolean ASTNode.fallsThrough() { return false;}
    /** Returns true if execution after this statement does not necessarily continue 
     * at the following statement. GotoStmt and IfStmt will both return true. */
    public boolean ASTNode.branches() { return false;}    
    
	// Index for all nodes
    private static int ASTNode.internalNodeID = 0;
    private int ASTNode.NodeID = 0;
    public void ASTNode.initNodeID() { internalNodeID=0;}
    public int ASTNode.nextNodeID() { return ++internalNodeID;}
    public int ASTNode.getNodeID() { return NodeID;}
    public int ASTNode.getLastNodeID() { return internalNodeID;}
    // Counter recording the # of temporary variables created from this program
    public static int ASTNode.VarCnt = 0;	
    // Only NodeID can only be set once.
    public boolean ASTNode.setNodeID() { 
    	if(NodeID==0) {
    		NodeID = nextNodeID();
    		return true;
    	} else
    		return false;
    }

    // Remove the UD/DU boxes
    public void ASTNode.clearUseDefBoxes()
    {
    	valueBoxes.clear();
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null)
                getChild(i).clearUseDefBoxes();
        }
    }
    public void AssignStmt.clearUseDefBoxes()
    {
    	if(defBoxes!=null)	defBoxes.clear();
    	super.clearUseDefBoxes();
    }

	// Nested level, starting from the Stmt
	public static int ASTNode.nestedLevelCounter = 0;
	public int ASTNode.nestedLevel = 0;

    //---------------------------------------------------------------------
    // Flow-Analysis related implementation
    // TODO: use-boxes have duplicated value-boxes
    //---------------------------------------------------------------------
    // AssignStmt: create Def-boxes
    //---------------------------------------------------------------------
    // took from soot.jimple.internal.AbstractDefinitionStmt
    public natlab.toolkits.ValueBox AssignStmt.leftBox;
    public natlab.toolkits.ValueBox AssignStmt.rightBox;
    
    java.util.List AssignStmt.defBoxes;

	// AssignStmt: doesn't generate new use-boxes
    // Notes: get(0) is created in Expr.generateUseBoxes() 
    //     valueBoxes.add(new natlab.toolkits.ASTValueBox(getStructureString()));
    public void AssignStmt.collectUseBoxesList() {
    	java.util.List leftBoxes = getLHS().getUseBoxes();
    	leftBox  = (natlab.toolkits.ValueBox) getLHS().getUseBoxes().get(0);
    	rightBox = (natlab.toolkits.ValueBox) getRHS().getUseBoxes().get(0);
    	if(getLHS() instanceof ParameterizedExpr) {
    		defBoxes = new java.util.ArrayList();
    		if(leftBoxes.size()>=2)
    			leftBox = (natlab.toolkits.ValueBox) leftBoxes.get(1);
    		defBoxes.add(leftBox);
    		for(int i=2; i<leftBoxes.size(); i++) {
    			valueBoxes.add(leftBoxes.get(i));
    		}
    	} else {
    		defBoxes = getLHS().getUseBoxes();
    	}
    	valueBoxes.addAll(getRHS().getUseBoxes());
    }

    // implements Unit interface
    public java.util.List AssignStmt.getDefBoxes()
    {
        return defBoxes;
    }
    
    public boolean AssignStmt.fallsThrough() { return true;}        
    public boolean AssignStmt.branches() { return false;}
/*
    // took from soot.jimple.internal.JAssignStmt
    public void AssignStmt.setLeftOp(Value variable)
    {
        leftBox.setValue(variable);
    }

    public void AssignStmt.setRightOp(Value rvalue)
    {
        rightBox.setValue(rvalue);
    }
*/
    //---------------------------------------------------------------------
    // Generate the use-boxes for all the nodes by traversing the tree
    public void ASTNode.generateUseBoxesList() {
    	// set the node ID first
    	setNodeID();
    	nestedLevel = nestedLevelCounter;	// Set the nested-level 
    	// Generate the uses boxes  
    	generateUseBoxes();
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null)
                getChild(i).generateUseBoxesList();
        }
        // Collecting the uses boxes 
        collectUseBoxesList();
    }

	// Set the nested-level for each node
	// ExprStmt, AssignStmt, ParameterizedExpr, BinaryExpr, MatrixExpr 
    public void ExprStmt.generateUseBoxesList() {
    	nestedLevelCounter++;
    	super.generateUseBoxesList();
    	nestedLevelCounter--;
    }
    public void AssignStmt.generateUseBoxesList() {
    	// Simplify RHS when LHS is a array access, 
    	if(getLHS() instanceof ParameterizedExpr && !(getRHS() instanceof NameExpr)) {
            nestedLevelCounter++;
            // Following is a modified version from ASTNode.generateUseBoxesList()
        	// set the node ID first
        	setNodeID();
        	nestedLevel = nestedLevelCounter;	 
        	// Generate the uses boxes  
        	generateUseBoxes();
        	// handle LHS() as normal
	    	getLHS().generateUseBoxesList();
	    	// handle RHS(), increase the nested-level-counter
	    	nestedLevelCounter++;
	    	getRHS().generateUseBoxesList();
            // Collecting the uses boxes 
            collectUseBoxesList();
            // restore nested-level-counter
	    	nestedLevelCounter-=2;
        } else {
        	nestedLevelCounter++;
        	super.generateUseBoxesList();
        	nestedLevelCounter--;
        }
    }
    
    public void ParameterizedExpr.generateUseBoxesList() {
    	nestedLevelCounter++;
    	super.generateUseBoxesList();
    	nestedLevelCounter--;
    }
    public void BinaryExpr.generateUseBoxesList() {
    	nestedLevelCounter++;
    	super.generateUseBoxesList();
    	nestedLevelCounter--;
    }
    public void RangeExpr.generateUseBoxesList() {
    	nestedLevelCounter++;
    	super.generateUseBoxesList();
    	nestedLevelCounter--;
    }
    public void MatrixExpr.generateUseBoxesList() {
    	nestedLevelCounter++;
    	// Following code is taken from 
    	// ASTNode.generateUseBoxesList();	
    	setNodeID();
    	nestedLevel = nestedLevelCounter;	// Set the nested-level 
    	getRowList().generateUseBoxesList();
		
        // Collecting the uses boxes - special need to handle it locally !
		// TODO: handle [a,b]=func()
        for(Row row : getRows()) {
        	java.util.List childUseBoxes = row.getUseBoxes();
            if( !childUseBoxes.isEmpty() ) {
                valueBoxes.addAll(childUseBoxes);
            }
        }
    	nestedLevelCounter--;
    }
    
    public void Row.generateUseBoxesList() {
    	nestedLevelCounter++;
    	// Following code is taken from 
    	// ASTNode.generateUseBoxesList();	
    	setNodeID();
    	nestedLevel = nestedLevelCounter;	// Set the nested-level 
    	getElementList().generateUseBoxesList();
   
        // Collecting the uses boxes - special need to handle it locally !
        for(Expr element : getElements()) {
        	java.util.List childUseBoxes = element.getUseBoxes();
            if( !childUseBoxes.isEmpty() ) {
                valueBoxes.addAll(childUseBoxes);
            }
        }
    	nestedLevelCounter--;
    }
    // All Transpose expression will be simplified
    public void MTransposeExpr.generateUseBoxesList() {
    	nestedLevelCounter+=2;
    	super.generateUseBoxesList();
    	nestedLevelCounter-=2;
    }

	// Generate function for collecting all its child-nodes' use-boxes
    public void ASTNode.collectUseBoxesListAll() {
        // Collecting the uses boxes 
        java.util.List childUseBoxes = null;
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null) {
            	childUseBoxes = getChild(i).getUseBoxes();
            }
	        if( !childUseBoxes.isEmpty() ) {
                valueBoxes.addAll(childUseBoxes);
            }
        }
    }

    // Default behavior, don't collect its children's use-boxes
    public void ASTNode.collectUseBoxesList() {
    }

	// Normal Stmt, Expr, collect its children's use-boxes
    public void Stmt.collectUseBoxesList() {
    	collectUseBoxesListAll();
    }
    public void Expr.collectUseBoxesList() {
    	collectUseBoxesListAll();
    }
	// But  ForStmt, WhileStmt, TryStmt, IfStmt, don't	// Needs DEBUG ........
    public void ForStmt.collectUseBoxesList() {}
    public void WhileStmt.collectUseBoxesList() {}
    public void TryStmt.collectUseBoxesList() {}
    public void SwitchStmt.collectUseBoxesList() {}		//??? There is use-box in Expr
    public void SwitchCaseBlock.collectUseBoxesList() {}
    public void DefaultCaseBlock.collectUseBoxesList() {}

    public void ParameterizedExpr.collectUseBoxesList() {
        java.util.List childUseBoxes = null;
        // Collecting the uses boxes : ParameterizedExpr ::= Target:Expr Arg:Expr*;
        childUseBoxes = getTarget().getUseBoxes();
        if( !childUseBoxes.isEmpty() ) {
            valueBoxes.addAll(childUseBoxes);
        }
        
        List<Expr> args = getArgs();
        for(Expr arg : args) {
	        childUseBoxes = arg.getUseBoxes();
	        if( !childUseBoxes.isEmpty() ) {
	            valueBoxes.addAll(childUseBoxes);
	        }
        }
    }

    public String ForStmt.getIndexVariable() {
    	AssignStmt  idxStmt = getAssignStmt();
    	return idxStmt.leftBox.getValue();
    }
    
    // Default behavior for creating new use-boxes
    public void ASTNode.generateUseBoxes() {
	    // valueBoxes.add(new natlab.toolkits.ASTValueBox(dumpStringAll()));
    }
    // According to AST, following node should not add new uses
    // EmptyStmt, NameExpr,...

	// 1. leaf-node: adding new uses
	// 2. internal-node: 
	//	(1) creating combined use : some 'Expr' nodes, i.g. x+y, BinaryExpr
	// 	(2) collecting use list: 
	//		(*) list of stmt: i.g. TryStmt, ... 
	//		(*) 1-to-1 node: i.g. NameExpr::=Name

    // Expr Node: includes NameExpr,
    // TODO: replace getStructureString()
    public void Expr.generateUseBoxes() {
        valueBoxes.add(new natlab.toolkits.ASTValueBox(getStructureString()));
    }
    
    // Name Node: is covered by the Expr...			// Delete it later ...
    // public void Name.generateUseBoxes() {
        // valueBoxes.add(new natlab.toolkits.ASTValueBox(getID()));
    // }
    
    //---------------------------------------------------------------------
    // Dumping all the nodes of the tree, with their use/def sets
    public static boolean ASTNode.bDumpCode=true;
    public String ASTNode.dumpTreeAll(boolean bWithCode) {
		bDumpCode = bWithCode;
        StringBuffer s = new StringBuffer();
        dumpTreeAll(s, 0);
        return s.toString();
    }
    public String ASTNode.dumpTreeAll() {
		return dumpTreeAll(true);
    }

    public void ASTNode.dumpTreeAll(StringBuffer s, int j) {
        for(int i = 0; i < j; i++) {
            s.append("  ");
        }
        s.append(dumpStringAll() + "\n");
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null)
                getChild(i).dumpTreeAll(s, j + 1);
        }
    }

    // Dumping every thing of the Node, including use/def sets
    public String ASTNode.dumpStringAll() {
		if(bDumpCode) {
			try {
				return " [<" + getNodeID() + ">]" + getClass().getName() 
					+ " [" + getStructureString() + "]"
					+ getDefBoxes() + getUseBoxes() + nestedLevel ; 
			} catch (Exception e) {
				return " [<" + getNodeID() + ">]" + getClass().getName() + " [" + toString() + "]"
					+ getDefBoxes() + getUseBoxes() + nestedLevel ;
			}
		} else { 
			return " [<" + getNodeID() + ">]" + getClass().getName();
		}
      
    }
    
    //---------------------------------------------------------------------
    // Dumping limited number of the nodes, that each of them contains only
    // one line of code (a single stmt), let's call it code-tree
    public String ASTNode.dumpCodeTree() {
		bDumpCode = true;
        StringBuffer s = new StringBuffer();
        dumpCodeTreeAll(s, 0);
        return s.toString();
    }

    public void ASTNode.dumpCodeTreeAll(StringBuffer s, int j) {
        for(int i = 0; i < j; i++) {
            s.append("  ");
        }
        s.append(dumpCode() + "\n");
        dumpCodeTreeAllChild(s, j);
    }    
    public void ASTNode.dumpCodeTreeAllChild(StringBuffer s, int j) {
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null)
                getChild(i).dumpCodeTreeAll(s, j + 1);
        }
	}    	
	// Using dumpStringAll by default
	public String ASTNode.dumpCode() {
    	return dumpStringAll();
	}

	// Nodes that don't traverse into their child-nodes
    public void AssignStmt.dumpCodeTreeAllChild(StringBuffer s, int j) {}
    public void Expr.dumpCodeTreeAllChild(StringBuffer s, int j) {}
    public void ExprStmt.dumpCodeTreeAllChild(StringBuffer s, int j) {}

	// Nodes don't have code 
	// internal nodes
    public String List.dumpCode() {return "";}
    public String Opt.dumpCode() {return "";}
    
    public String EmptyStmt.dumpCode() {return "";}
    
    
	// Nodes have muliti-line code
	// Program nodes
    public String Program.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}

	// Special nodes     
    public String ForStmt.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}
    public String WhileStmt.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}
    public String TryStmt.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}
    public String SwitchStmt.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}		
    public String SwitchCaseBlock.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}
    public String DefaultCaseBlock.dumpCode() { return " [<" + getNodeID() + ">]" + getClass().getName();}

    //---------------------------------------------------------------------
    // Interface for Visit pattern, called when this object is visited. 
    //  Program, the root node of the AST, it could be Script, FunctionList, EmptyProgram. 
    //---------------------------------------------------------------------
    public void ASTNode.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseASTNode(this);
        applyAllChild(visitor);
    }
    public void ASTNode.applyAllChild(natlab.toolkits.analysis.ASTVisitor visitor) {
        for(int i = 0; i < getNumChild(); i++) {
            if (getChild(i)!=null)
                getChild(i).apply(visitor);
        }
    }
	// Nodes that don't traverse into their child-nodes
    public void AssignStmt.applyAllChild(natlab.toolkits.analysis.ASTVisitor visitor) {}
    public void Expr.applyAllChild(natlab.toolkits.analysis.ASTVisitor visitor) {}
    public void ExprStmt.applyAllChild(natlab.toolkits.analysis.ASTVisitor visitor) {}

    // Nodes that don't need apply
    public void EmptyStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {}

	// loop-nodes
    public void WhileStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseLoopStmt(this);
    }
    public void ForStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseLoopStmt(this);
    }

	// if-elseif-else nodes
    public void IfStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseIfStmt(this);
    }
	// Switch nodes
    public void SwitchStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseSwitchStmt(this);
    }

	// branching nodes : BreakStmt, ContinueStmt, ReturnStmt
    public void BreakStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseBranchingStmt(this);
    }
    public void ContinueStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseBranchingStmt(this);
    }    
    public void ReturnStmt.apply(natlab.toolkits.analysis.ASTVisitor visitor) {
        visitor.caseBranchingStmt(this);
    }    
    
}
