/*
 *  Collecting type from each sub-nodes
 *  Used when inferring a variable's type from its AssignStmt node 
 *  It will be called from outside, i.e.
 *		varType = ((AssignStmt) parentNode).getRHS().collectType(stScope, varNode);
 */
import java.util.*;

aspect TypeCollection {

	// TODO: TIEngine should be replace by "natlab.TypeInferenceEngine", since we only call its static methods
	//public static natlab.TypeInferenceEngine ASTNode.TIEngine;
	//public void ASTNode.setTypeInferenceEngine(natlab.TypeInferenceEngine tie) {
	//	TIEngine = tie;
	//}
	public static natlab.SymbolTableScope ASTNode.gstScope;
	public void ASTNode.setSymbolTableScope(natlab.SymbolTableScope scope) {
		gstScope = scope;
	}

	// varNode : the variable definition node of that symbol entry
	public annotations.ast.Type ASTNode.collectType(SymbolTableScope stScope, ASTNode varNode) {
		annotations.ast.Type childType = null;
		for(int i = 0; i < getNumChild(); i++) {
			childType = getChild(i).collectType(stScope, varNode);
			// Do sth to use children's type
		}
		if(getNumChild()>1)
			System.err.println("[ASTNode.collectType] This node has "+getNumChild()+" children");
		return null;
	}
/***
	// Starting from ExprStmt, AssignStmt
	public annotations.ast.Type ExprStmt.collectType(SymbolTableScope stScope, ASTNode varNode) {
		if(nestedLevel==1) {
			if(getParent() instanceof List) {
				List list = (List)getParent();
				this.childLocation = list.getIndexOfChild(this);
				for(int i = 0; i < getNumChild(); i++) {
					if (getChild(i)!=null) {
						annotations.ast.Type childType = getChild(i).collectType(list, 2);
						if(replacementNode != null) 
							setChild(replacementNode,i);
					}
		        }
			} else {
			}
		}	
		return null;
	}
	public annotations.ast.Type AssignStmt.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		if(nestedLevel==1) {
			if(getParent() instanceof List) {
				List list = (List)getParent();
				this.childLocation = list.getIndexOfChild(this);
				for(int i = 0; i < getNumChild(); i++) {
					if (getChild(i)!=null) {
						annotations.ast.Type childType = getChild(i).collectType(list, 2);
						if(replacementNode != null) 
							setChild(replacementNode,i);
					}
		        }
			} else {
			}
		}	
		return null;
	}

	// Public Function, for performing simplification tranformation.
	// It only can be called by several kind of Expr, assert(this instanceof Expr);
	public annotations.ast.Type Expr.simplifyTranform(SymbolTableScope stScope, ASTNode varNode) {		
		if(nestedLevel>level) {
			// (1). Create new temporary variable, by Symbol-Table interface
			// VariableDeclaration varDecl = createTempVar(type());
			String tmpName = "tmpvar_" + getNodeID();
			
			// (2). Create NameExpr node
			NameExpr tmpNameExpr = new NameExpr(new Name(tmpName));
			
			// (3). Create AssignStmt, add to the top Stmt-List, just before current node			
			stmtList.insertChild(new AssignStmt(tmpNameExpr, (Expr)this), this.childLocation);
			this.childLocation++;
			
			// (4) return new replacement node
			return tmpNameExpr;
		} else {
			return null;
		}
	}
**/	
	// stmtList: stmt-list from the top of the subtree, where we can add stmt on it
	// level : the level, all node deeper than this level need to be simplified.
	// RETURN : null, if there is no collectType need to do.
	//		    otherwise, new replacement node, 
	public annotations.ast.Type BinaryExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// 1. Calling to next level 
		annotations.ast.Type lhsType = getLHS().collectType(stScope, varNode);
		annotations.ast.Type rhsType = getRHS().collectType(stScope, varNode);

		// 2. Calling type inference engine to get the type
		return natlab.TypeInferenceEngine.inferType(stScope, this, lhsType, rhsType, varNode);
	}
	public annotations.ast.Type UnaryExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// 1. Calling to next level 
		annotations.ast.Type opType = getOperand().collectType(stScope, varNode);

		// 2. Calling type inference engine to get the type
		return natlab.TypeInferenceEngine.inferType(stScope, this, opType, varNode);
	}
	
	public annotations.ast.Type NameExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// 1. Calling to next level 
		
		// 2. Calling type inference engine to get the type
		return natlab.TypeInferenceEngine.inferType(stScope, this, varNode);
	}
	public boolean ParameterizedExpr.isVariable = false;
	public annotations.ast.Type ParameterizedExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		return natlab.TypeInferenceEngine.inferType(stScope, this, varNode);
	}
	
	public annotations.ast.Type IntLiteralExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		return new annotations.ast.PrimitiveType("int");
	}
	public annotations.ast.Type FPLiteralExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		return new annotations.ast.PrimitiveType("double");
	}
	public annotations.ast.Type StringLiteralExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		return new annotations.ast.PrimitiveType("character("+(getValue().length())+")");
	}

	//	(1) First KNOWN element's type is the element type
	//	(2) Calculate the #Row and #column
	// 	(3) #column may should be the maximum one
	public annotations.ast.Type MatrixExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// #. Calling type inference engine to get the type
		return natlab.TypeInferenceEngine.inferType(stScope, this, varNode);
	}

	public annotations.ast.Type Row.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// #. Calling type inference engine to get the type
		return natlab.TypeInferenceEngine.inferType(stScope, this, varNode);
	}
	
	// i.e.  for i=(1:runs) in an integer, handle here.
	// i.e.  var =(1:runs)  is an array, call into natlab.TypeInferenceEngine.inferType()
	public annotations.ast.Type RangeExpr.collectType(SymbolTableScope stScope, ASTNode varNode)  {
		// 1. get element type
		annotations.ast.Type typeLower = getLower().collectType(stScope, varNode);
		annotations.ast.Type typeUpper = getUpper().collectType(stScope, varNode);

		// 2. Choose one of them
        ASTNode parentAssign = getParent();
        // Only try less 10 time
        for(int i = 1; i<10;i++) {
        	if(parentAssign instanceof AssignStmt) 
        		break;
        	else
        		parentAssign = parentAssign.getParent();
        }
//        if ((parentAssign instanceof AssignStmt)
//        		&& parentAssign.getParent() instanceof ForStmt) {
//			return new annotations.ast.PrimitiveType("int");
//		} else {
			return natlab.TypeInferenceEngine.inferType(stScope, this, varNode);
//		}
	}

}

//-----------------------------------------------------------------------------
// For updating symbol table scope, adding decl nodes
//-----------------------------------------------------------------------------
aspect UpdateSymbolTableScope {

	//-------------------------------------------------------------------------
	// Symbol Table Scope : This will be implemented in Script, Function, FunctionDecl
	//-------------------------------------------------------------------------
    public SymbolTableScope ASTNode.updateSymbolTableScope(SymbolTableScope symtbl) {
    	return symtbl;
    }
    
    private boolean Function.bParamDeclAdded = false;
    public SymbolTableScope Function.updateSymbolTableScope(SymbolTableScope symtbl) {
    	// Finding the VariableDecl node for each entry,	
    	if(!bParamDeclAdded) {
    		// Adding input/output parameters,  skip dumplicated, 
	    	List<VariableDecl> pDeclList = getParamDeclList();
	    	java.util.HashSet<String> varSet = new java.util.HashSet<String>(); 
	    	for(VariableDecl decl: pDeclList) {
	    		if(!varSet.contains(decl.getID())) {
		    		varSet.add(decl.getID());
		    		addDeclStmt(decl);
	    		}
	    	}
    	}

    	// If decl-node not found, create one,
    	boolean found = false;
	    for( SymbolTableEntry e : symtbl.symTable.values() ) {
	    	if(e.getDeclLocation()==null) {
	    		found = false;
		    	for(VariableDecl decl: varDeclList) {
		    		if(decl.getID().equals(e.getSymbol())) {
		    			e.setDeclLocation(decl);
		    			found = true;
		    			break;
		    		}
		    	}
		    	if(!found) {
		    		VariableDecl decl = new VariableDecl(e.getSymbol(), 
		    				new annotations.ast.UnknownType() );
		    		addDeclStmt( decl );
		    		e.setDeclLocation(decl);
		    	}
	    	}
    	}
	    // Make sure all decl node has symbol table entry, 
	    // for those don't, create entry for them. 
	    // (this is designed for function parameter list)
    	for(VariableDecl decl: varDeclList) {
    		String name = decl.getID();
    		SymbolTableEntry stEntry = symtbl.getSymbolById(name);
    		if(stEntry == null) {
    			stEntry = new SymbolTableEntry(name, name, decl);
    			stEntry.setDeclLocation(decl);
    			symtbl.addSymbol(stEntry);
    		}
    	}
	    
    	return symtbl;
    }
    
    public SymbolTableScope Script.updateSymbolTableScope(SymbolTableScope symtbl) {

    	// Finding the VariableDecl node for each entry,	-JL 10.03
    	// if not found, create one,
    	boolean found = false;
	    for( SymbolTableEntry e : symtbl.symTable.values() ) {
	    	if(e.getDeclLocation()==null) {
	    		found = false;
		    	for(VariableDecl decl: varDeclList) {
		    		if(decl.getID().equals(e.getSymbol())) {
		    			e.setDeclLocation(decl);
		    			found = true;
		    			break;
		    		}
		    	}
		    	if(!found) {
		    		VariableDecl decl = new VariableDecl(e.getSymbol(), 
		    				new annotations.ast.UnknownType() );
		    		addDeclStmt( decl );
		    		e.setDeclLocation(decl);
		    	}
	    	}
    	}
        
    	return symtbl;
    }
    

    // ----------------------------------------------------------------------------
	// List function's declarations for input/output parameters 
	// Same functionality as the one in FunctionDecl
	private List<VariableDecl> Function.paramDeclStmtList=null;	
	public List<VariableDecl> Function.getParamDeclList()
	{
		if(paramDeclStmtList==null) {
			paramDeclStmtList=new List<VariableDecl>();
			VariableDecl paramDecl;
			for(Name param: getInputParamList()) {
				paramDecl = new VariableDecl(param.getID(), new annotations.ast.UnknownType() );
				paramDeclStmtList.add(paramDecl);
			}
			for(Name param: getOutputParamList()) {
				paramDecl = new VariableDecl(param.getID(), new annotations.ast.UnknownType() );
				paramDeclStmtList.add(paramDecl);
			}
		}
		return paramDeclStmtList;
	}
	
    // ----------------------------------------------------------------------------
    // Following code are taken from NameResolution.jrag, which is used 
    // to help creating declaration node, with symbol table
    
    // Extra function to help save list of VariableDecl node, same as those in Script	-JL 
    private int Function.lastDeclLocation=0;
    private List Function.declStmtList=null;
    protected java.util.List<VariableDecl> Function.varDeclList = new ArrayList<VariableDecl>();
    public  java.util.List<VariableDecl> Function.getDeclList() { return varDeclList;}
	public void Function.addDeclStmt(VariableDecl node) {
		if(declStmtList == null) {
			declStmtList = getStmtList();
			lastDeclLocation = 0;
		} 
		declStmtList.insertChild(node, lastDeclLocation++);
        // Save info of last adding new VariableDecl()     	
    	varDeclList.add((VariableDecl) node);
	}

    // For Script
    private int Script.lastDeclLocation=0;
    private List Script.declStmtList=null;
    private java.util.List<VariableDecl> Script.varDeclList = new ArrayList<VariableDecl>();
    public  java.util.List<VariableDecl> Script.getDeclList() { return varDeclList;}
	public void Script.addDeclStmt(VariableDecl node) {
		if(declStmtList == null) {
			declStmtList = getStmtList();
			lastDeclLocation = 0;
		} 
		declStmtList.insertChild(node, lastDeclLocation++);
        // Save info of last adding new VariableDecl()     	
    	varDeclList.add((VariableDecl) node);
	}
    // ----------------------------------------------------------------------------
    
	
    // ----------------------------------------------------------------------------
    // Extra constructor for VariableDecl
    public VariableDecl.VariableDecl(String p0, annotations.ast.Type p1) {
        setID(p0);
        setType(p1);
        // setOriginalID(p1);
    }

}
