import natlab.SymbolTableEntry;
import java.util.*;

aspect NameResolution{


    syn lazy Name Program.lookupLValue(String name) = null;
    syn lazy Name Stmt.lookupLValue(String name) = null;
    syn lazy Name Expr.lookupSymbol(String name) = null;

    //inh HashMap<String, Name> Expr.getLValues();

    //eq EmptyProgram.lookupLValue( String name ) = null;

    eq Script.lookupLValue( String name ) = null;
    /*
    {
        return getLValues().get(name);
    }

    eq FunctionList.lookupLValue( String name )
    {
        return null;
    }

    //eq ClassDef.lookupLValue( String name ) = null;
        
    //eq AssignStmt.lookupLValue( String name ) = getLHS().lookupSymbol( name );


    eq NameExpr.lookupSymbol( String name ) 
    {
        return getSymbols().get(name);
    }

    eq ParameterizedExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq CellIndexExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq DotExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq MatrixExpr.lookupSymbol( String name )
    {
        return getSymbols().get(name);
    }
    */

    //getLValues methods, returns a Map of name to Name nodes of all L Value name nodes.

    syn lazy Set<String> Script.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumStmt(); i++ )
            names.addAll( getStmt(i).getLValues() );
        return names;
    }
    syn lazy Set<String> Function.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumStmt(); i++ )
            names.addAll( getStmt(i).getLValues() );
        return names;
    }

    syn lazy Set<String> Stmt.getLValues() = new LinkedHashSet<String>();
    syn Set<String> Expr.getSymbols() = new LinkedHashSet<String>();

    syn Set<String> Name.getSymbols()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        names.add( getID() );
        return names;
    }


    //getLValues equations for Statements
    eq AssignStmt.getLValues() = getLHS().getSymbols();
    eq GlobalStmt.getLValues() 
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumName(); i++ ){
            names.add(getName(i).getID());
        }
        return names;
    }
    eq PersistentStmt.getLValues() 
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumName(); i++ ){
            names.add(getName(i).getID());
        }
        return names;
    }
    eq ForStmt.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        names.addAll( getAssignStmt().getLValues() );
        for( int i=0; i<getNumStmt(); i++ )
            names.addAll(getStmt(i).getLValues() );
        return names;
    }
    eq WhileStmt.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumStmt(); i++ )
            names.addAll(getStmt(i).getLValues() );
        return names;
    }
    eq IfStmt.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumIfBlock(); i++ ){
            for( int j=0; j<getIfBlock(i).getNumStmt(); j++ ){
                names.addAll(getIfBlock(i).getStmt(j).getLValues());
            }
        }
        if( hasElseBlock() )
            for( int i=0; i<getElseBlock().getNumStmt(); i++ )
                names.addAll(getElseBlock().getStmt(i).getLValues());
        return names;
    }
    eq TryStmt.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumTryStmt(); i++ )
            names.addAll( getTryStmt(i).getLValues() );
        for( int i=0; i<getNumCatchStmt(); i++ )
            names.addAll( getCatchStmt(i).getLValues() );
        return names;
    }
    eq SwitchStmt.getLValues()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumSwitchCaseBlock(); i++){
            SwitchCaseBlock b = getSwitchCaseBlock(i);
            for( int j=0; j<b.getNumStmt(); j++ )
                names.addAll( b.getStmt(j).getLValues() );
        }
        if( hasDefaultCaseBlock() ){
            DefaultCaseBlock b = getDefaultCaseBlock();
            for( int i=0; i< b.getNumStmt(); i++ )
                names.addAll( b.getStmt(i).getLValues() );
        }
        return names;
    }
   

    //getSymbols equations for Expressions
    eq NameExpr.getSymbols() = getName().getSymbols();
    eq ParameterizedExpr.getSymbols() = getTarget().getSymbols();
    eq CellIndexExpr.getSymbols() = getTarget().getSymbols();
    eq DotExpr.getSymbols() = getTarget().getSymbols();
    eq MatrixExpr.getSymbols()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumRow(); i++ ){
            for( int j=0; j< getRow(i).getNumElement(); j++ ){
                names.addAll( getRow(i).getElement(j).getSymbols() );
            }
        }
        return names;
    }

    //isLValue test for names
    inh boolean Name.isLValue();

    //default value
    eq Script.getStmt(int i).isLValue() = false;
    eq ClassDef.getMethod(int i).isLValue() = false;
    eq ClassDef.getClassEvent(int i).isLValue() = false;
    eq ClassDef.getProperty(int i).isLValue() = false;
    eq FunctionList.getFunction(int i).isLValue() = false;

    //overides 
    eq AssignStmt.getLHS().isLValue() = true;
    eq AssignStmt.getRHS().isLValue() = true;
    eq GlobalStmt.getName().isLValue() = true;
    eq PersistentStmt.getName().isLValue() = true; //TODO-JD:is this true?


    //function lookup implementation
    syn Function FunctionList.getMainFunction() = getFunction(0);

    syn lazy Map<String,Function> FunctionList.getSiblings() = new HashMap<String,Function>();
    syn lazy Map<String,Function> FunctionList.getNested()
    {
        HashMap<String,Function> table = new HashMap<String,Function>();
        for( int i=0; i<getNumFunction(); i++ ){
            table.put( getFunction(i).getName(), getFunction(i) );
        }
        //TODO-JD: add alias for main function with file name
        return table;
    }
    syn LocalFunctionLookupInterface FunctionList.getParentFunction() = null;

    syn lazy Map<String,Function> Function.getNested()
    {
        HashMap<String, Function> table = new HashMap<String,Function>();
        for( int i=0; i<getNumNestedFunction(); i++ ){
            table.put( getNestedFunction(i).getName(), getNestedFunction(i) );
        }
        return table;
    }
    //TODO-JD: This inh attribute should return Map<String,Function> but JastAdd
    //does not currently support inh attributes with generics like that (it's a 
    //bug). When this is fixed, need to change this and remove the syn wrapper
    //below
    inh Map Function.getSiblingsInh();    
    eq FunctionList.getFunction(int i).getSiblingsInh() = getNested();
    eq Function.getNestedFunction(int i).getSiblingsInh() = getNested();
    eq ClassDef.getMethod(int i).getSiblingsInh() = new HashMap<String,Function>();

    syn lazy Map<String,Function> Function.getSiblings() = (Map<String,Function>)getSiblingsInh();

    inh LocalFunctionLookupInterface Function.getParentFunction();
    eq FunctionList.getFunction(int i).getParentFunction() = this;
    eq Function.getNestedFunction(int i).getParentFunction() = this;
    eq ClassDef.getMethod(int i).getParentFunction() = null; //TODO-JD: fix this

    syn Function Function.lookupFunction( String name )
    {
        Function f = getNested().get(name);
        if( f != null )
            return f;
        return getParentFunction().lookupFunction( name );
    }
    syn Function FunctionList.lookupFunction( String name )
    {
        return getNested().get(name);
    }

    //helper function to get all visible functions from a given Function
    //this probably won't be called often
    syn Map<String,Function> FunctionList.getVisible()
    {
        /*HashMap<String,Function> table = new HashMap<String,Function>();
        table.put(getMainFunction().getName(), getMainFunction());
        return table;*/
        return getNested();
    }
    syn Map<String,Function> Function.getVisible()
    {
        Map<String,Function> table = getParentFunction().getVisible();
        table.putAll(getNested());
        return table;
    }

    //get a set containing all input and output parameters for a function
    syn lazy Set<String> Function.getOutParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumOutputParam(); i++ ){
            if( !names.add( getOutputParam(i).getID() ) )
                //TODO-JD:add error msg
                System.err.println("duplicate output parameters");
        }
        return names;
    }
    syn lazy Set<String> Function.getInParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumInputParam(); i++ ){
            if( !names.add( getInputParam(i).getID() ) )
                //TODO-JD:add error msg
                System.err.println("duplicate input parameters");
        }
        return names;
    }
        
    syn lazy Set<String> Function.getParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        names.addAll(getInParamSet());
        names.addAll(getOutParamSet());
        return names;
    }
    // Extra function to help save list of VariableDecl node	-JL 10.03
	private static int Script.lastDeclLocation=0;
    private List Script.declStmtList=null;
    private java.util.List<VariableDecl> Script.varDeclList = new ArrayList<VariableDecl>();
    public  java.util.List<VariableDecl> Script.getDeclList() { return varDeclList;}
	public void Script.addDeclStmt(VariableDecl node) {
		if(declStmtList == null) {
			declStmtList = getStmtList();
			declStmtList.addChild(node);
			lastDeclLocation = declStmtList.numChildren();
		} else {
			declStmtList.insertChild(node, lastDeclLocation++);
		} 
        // Save info of last adding new VariableDecl()     	
    	varDeclList.add((VariableDecl) node);
	}
    
    // Adding Declaration nodes
    
    private boolean Script.doneDeclRewrite = false;
    rewrite Script{
        when( doDeclRewrite() && !doneDeclRewrite )
        to Script{
            System.out.println("yo");
            Script s = new Script();
            s.setHelpCommentList(getHelpCommentList());
            for( String symbol : getLValues() )
                s.addDeclStmt( new VariableDecl(symbol, new annotations.ast.UnknownType() ) );
            for( int i=0; i<getNumStmt(); i++ ){
                s.addStmt( getStmt(i) );
            }
            s.doneDeclRewrite = true;
            return s;
        }
    }

    rewrite Function{
        when( doDeclRewrite() && !(this instanceof FunctionDecl) )
        to FunctionDecl{
            FunctionDecl f = new FunctionDecl();
            //set f with all the same data as original function
            //except for the stmt list
            f.setOutputParamList( getOutputParamList() );
            f.setName( getName() );
            f.setInputParamList( getInputParamList() );
            f.setHelpCommentList( getHelpCommentList() );
            f.setNestedFunctionList( getNestedFunctionList() );

            //add DeclStmts
            Set<String> params = getParamSet();
            for( String symbol : getLValues() )
                //only add decls for non parameters
                if( !params.contains( symbol ) )
                    f.addStmt( new VariableDecl(symbol, new annotations.ast.UnknownType() ) );
            //add original stmts
            for( int i=0; i<getNumStmt(); i++ ){
                f.addStmt( getStmt(i) );
            }
            //add Parameter declarations
            for( String symbol : getParamSet() )
              f.addParamDecl( new VariableDecl(symbol, new annotations.ast.UnknownType() ) );
            return f;
        }
    }
    //syn boolean ASTNode.doRewrite() = getParent().doRewrite();
    //eq Program.doRewrite() = canDoRewrites;
    inh boolean ASTNode.doDeclRewrite();

    eq Program.getChild(int i).doDeclRewrite() = canDoDeclRewrites;
    syn boolean Program.doDeclRewrite() = canDoDeclRewrites;
        

}