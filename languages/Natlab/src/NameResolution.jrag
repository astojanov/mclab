// =========================================================================== //
//                                                                             //
// Copyright 2008-2011 Andrew Casey, Jun Li, Jesse Doherty,                    //
//   Maxime Chevalier-Boisvert, Toheed Aslam, Anton Dubrau, Nurudeen Lameed,   //
//   Amina Aslam, Rahul Garg, Soroush Radpour, Olivier Savary Belanger,        //
//   Laurie Hendren, Clark Verbrugge and McGill University.                    //
//                                                                             //
//   Licensed under the Apache License, Version 2.0 (the "License");           //
//   you may not use this file except in compliance with the License.          //
//   You may obtain a copy of the License at                                   //
//                                                                             //
//       http://www.apache.org/licenses/LICENSE-2.0                            //
//                                                                             //
//   Unless required by applicable law or agreed to in writing, software       //
//   distributed under the License is distributed on an "AS IS" BASIS,         //
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//   See the License for the specific language governing permissions and       //
//   limitations under the License.                                            //
//                                                                             //
// =========================================================================== //

import natlab.SymbolTableEntry;
import java.util.*;

aspect NameResolution{


    syn lazy Name Program.lookupLValue(String name) = null;
    syn lazy Name Stmt.lookupLValue(String name) = null;
    syn lazy Name Expr.lookupSymbol(String name) = null;

    //inh HashMap<String, Name> Expr.getLValues();

    //eq EmptyProgram.lookupLValue( String name ) = null;

    eq Script.lookupLValue( String name ) = null;
    /*
    {
        return getLValues().get(name);
    }

    eq FunctionList.lookupLValue( String name )
    {
        return null;
    }

    //eq ClassDef.lookupLValue( String name ) = null;
        
    //eq AssignStmt.lookupLValue( String name ) = getLHS().lookupSymbol( name );


    eq NameExpr.lookupSymbol( String name ) 
    {
        return getSymbols().get(name);
    }

    eq ParameterizedExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq CellIndexExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq DotExpr.lookupSymbol( String name ) = getTarget().lookupSymbol( name );
    eq MatrixExpr.lookupSymbol( String name )
    {
        return getSymbols().get(name);
    }
    */


    //isLValue test for names
    inh boolean Name.isLValue();

    //default value
    eq Script.getStmt(int i).isLValue() = false;
    eq ClassDef.getMethod(int i).isLValue() = false;
    eq ClassDef.getClassEvent(int i).isLValue() = false;
    eq ClassDef.getProperty(int i).isLValue() = false;
    eq ClassDef.getAttribute(int i).isLValue() = false;
    eq FunctionList.getFunction(int i).isLValue() = false;

    //overides 
    eq AssignStmt.getLHS().isLValue() = true;
    eq AssignStmt.getRHS().isLValue() = true;
    eq GlobalStmt.getName().isLValue() = true;
    eq PersistentStmt.getName().isLValue() = true; //TODO-JD:is this true?


    //function lookup implementation
    syn Function FunctionList.getMainFunction() = getFunction(0);

    syn lazy Map<String,Function> FunctionList.getSiblings() = new HashMap<String,Function>();
    syn lazy Map<String,Function> FunctionList.getNested()
    {
        HashMap<String,Function> table = new HashMap<String,Function>();
        for( int i=0; i<getNumFunction(); i++ ){
            table.put( getFunction(i).getName(), getFunction(i) );
        }
        //TODO-JD: add alias for main function with file name
        return table;
    }
    syn LocalFunctionLookupInterface FunctionList.getParentFunction() = null;

    syn lazy Map<String,Function> Function.getNested()
    {
        HashMap<String, Function> table = new HashMap<String,Function>();
        for( int i=0; i<getNumNestedFunction(); i++ ){
            table.put( getNestedFunction(i).getName(), getNestedFunction(i) );
        }
        return table;
    }
    //TODO-JD: This inh attribute should return Map<String,Function> but JastAdd
    //does not currently support inh attributes with generics like that (it's a 
    //bug). When this is fixed, need to change this and remove the syn wrapper
    //below
    inh Map Function.getSiblingsInh();    
    eq FunctionList.getFunction(int i).getSiblingsInh() = getNested();
    eq Function.getNestedFunction(int i).getSiblingsInh() = getNested();
    eq ClassDef.getMethod(int i).getSiblingsInh() = new HashMap<String,Function>();

    syn lazy Map<String,Function> Function.getSiblings() = (Map<String,Function>)getSiblingsInh();

    inh LocalFunctionLookupInterface Function.getParentFunction();
    eq FunctionList.getFunction(int i).getParentFunction() = this;
    eq Function.getNestedFunction(int i).getParentFunction() = this;
    eq ClassDef.getMethod(int i).getParentFunction() = null; //TODO-JD: fix this

    syn Function Function.lookupFunction( String name )
    {
        Function f = getNested().get(name);
        if( f != null )
            return f;
        if (getParentFunction() == null) return null;
        return getParentFunction().lookupFunction( name );
    }
    syn Function FunctionList.lookupFunction( String name )
    {
        return getNested().get(name);
    }

    //helper function to get all visible functions from a given Function
    //this probably won't be called often
    syn Map<String,Function> FunctionList.getVisible()
    {
        /*HashMap<String,Function> table = new HashMap<String,Function>();
        table.put(getMainFunction().getName(), getMainFunction());
        return table;*/
        return getNested();
    }
    syn Map<String,Function> Function.getVisible()
    {
        Map<String,Function> table = getParentFunction().getVisible();
        table.putAll(getNested());
        return table;
    }

    //get a set containing all input and output parameters for a function
    syn lazy Set<String> Function.getOutParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumOutputParam(); i++ ){
            if( !names.add( getOutputParam(i).getID() ) )
                //TODO-JD:add error msg
                System.err.println("duplicate output parameters");
        }
        return names;
    }
    syn lazy Set<String> Function.getInParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        for( int i=0; i<getNumInputParam(); i++ ){
            if( !names.add( getInputParam(i).getID() ) )
                //TODO-JD:add error msg
                System.err.println("duplicate input parameters");
        }
        return names;
    }
        
    syn lazy Set<String> Function.getParamSet()
    {
        LinkedHashSet<String> names = new LinkedHashSet<String>();
        names.addAll(getInParamSet());
        names.addAll(getOutParamSet());
        return names;
    }
    
    // Adding Declaration nodes
    
    private boolean Script.doneDeclRewrite = false;
    /* adding these nodes breaks McFor
    rewrite Script{
        when( getParent()!=null && doDeclRewrite() && !doneDeclRewrite )
        to Script{
            Script s = new Script();
            s.setHelpCommentList(getHelpCommentList());
            for( String symbol : getLValues() ){
                //TODO JD:UPDATE TYPES
                //New version
                //VariableDecl d = new VariableDecl(symbol, new UnknownType(), symbol );
                //Old version
                VariableDecl d = new VariableDecl(symbol, new annotations.ast.UnknownType(), symbol );
                s.addDeclStmt( d );
                /*if( d.getType() == null )
                    System.out.println(symbol + "'s type is null after instanciation");
                else
                    System.out.println(symbol + "'s type is not null after instanciation");
                // * /
            }
            for( int i=0; i<getNumStmt(); i++ ){
                s.addStmt( getStmt(i) );
            }
            s.doneDeclRewrite = true;
            return s;
        }
    }
    */

    /*
    rewrite Function{
        when( getParent()!=null && doDeclRewrite() && !(this instanceof FunctionDecl) )
        to FunctionDecl{
            FunctionDecl f = new FunctionDecl();
            //set f with all the same data as original function
            //except for the stmt list
            f.setOutputParamList( getOutputParamList() );
            f.setName( getName() );
            f.setInputParamList( getInputParamList() );
            f.setHelpCommentList( getHelpCommentList() );
            f.setNestedFunctionList( getNestedFunctionList() );
            f.setComments( getComments() );

            //add DeclStmts
            Set<String> params = getParamSet();
            for( String symbol : getLValues() )
                //only add decls for non parameters
                if( !params.contains( symbol ) )
                    f.addStmt( new VariableDecl(symbol, new annotations.ast.UnknownType(), symbol) );
            //add original stmts
            for( int i=0; i<getNumStmt(); i++ ){
                Stmt s = getStmt(i);
                f.addStmt( s );
            }
            //add Parameter declarations
            for( String symbol : getParamSet() )
                //TODO JD:UPDATE TYPES
                //new version
                //f.addParamDecl( new VariableDecl(symbol, new UnknownType(), symbol ) );
                //old version
                f.addParamDecl( new VariableDecl(symbol, new annotations.ast.UnknownType(), symbol ) );
            return f;
        }
    }
    */


    //syn boolean ASTNode.doRewrite() = getParent().doRewrite();
    //eq Program.doRewrite() = canDoRewrites;
    inh boolean ASTNode.doDeclRewrite();

    eq List.getChild(int i).doDeclRewrite(){
        if( getParent() == null )
            return false;
        else
            return doDeclRewrite();
    }
    eq Program.getChild(int i).doDeclRewrite() = canDoDeclRewrites;
    syn boolean Program.doDeclRewrite() = canDoDeclRewrites;
        

}