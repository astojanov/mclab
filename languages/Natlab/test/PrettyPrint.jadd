/*
 *  Adapted for Natlab project 
 *  from PrettyPrint.jadd of JastAdd Extensible Java Compiler 
 *  (http://jastadd.org) created by Torbjorn Ekman.
 *
 */
import java.util.*;

aspect PrettyPrint {
	
  // For getStructureString()
  
  public String ASTNode.getStructureString() {
    StringBuffer s = new StringBuffer();
    s.append(dumpStringOnly() + "");
    return s.toString();
  }

  syn String ASTNode.dumpStringOnly() = toString() ;
  eq DoubleLiteral.dumpStringOnly() = getValue().getText() ;
  eq IntegerLiteral.dumpStringOnly() = getValue().getText() ;
  eq StringLiteral.dumpStringOnly() = getValue() ;
  eq ParseName.dumpStringOnly() = getID() ;
  eq MethodAccess.dumpStringOnly() = getID() ;
  eq MatrixAccess.dumpStringOnly() = getID() ;

  // Helper for indentation  
  protected static int ASTNode.indent = 0;
  
  public static String ASTNode.indent() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < indent; i++) {
      s.append("  ");
    }
    return s.toString();
  }

  // Default output
  
  public String ASTNode.toString() {
    StringBuffer s = new StringBuffer();
    toString(s);
    return s.toString().trim();
  }
  
  public void ASTNode.toString(StringBuffer s) {
    //  throw new Error("ERROR: toString(StringBuffer s) not implemented for " + getClass().getName());
      s.append("WARNING: toString(StringBuffer s) not implemented for " + getClass().getName()+"\n");
  }
  public void List.toString(StringBuffer s) {
      s.append("-- in List --");
  }
  public void Opt.toString(StringBuffer s) {
      s.append("-- in Opt --");
  }

  public void Program.toString(StringBuffer s) {
    for(Iterator iter = getStmts().iterator(); iter.hasNext(); ) {
      Stmt stmt = (Stmt)iter.next();
      stmt.toString(s);
    }
  }

  // Flow control ... 

  public void ForStmt.toString(StringBuffer s) {
    s.append("FOR ");
    s.append("(");		// need adjust ...
    getAssignStmt().toString(s);
    s.append(");\n");
    for(Iterator iter = getStmts().iterator(); iter.hasNext(); ) {
      Stmt stmt = (Stmt)iter.next();
      stmt.toString(s);
    }
    s.append("END ");
  }

  // Assign Expression

  public void AssignStmt.toString(StringBuffer s) {
    getDest().toString(s);
    s.append(printOp());
    getSource().toString(s);
    s.append(";\n");
  }

  syn String AssignStmt.printOp() = " = ";
  
  // Colon Expression
  
  public void ColonExpr.toString(StringBuffer s) {
    getBase().toString(s);
  	s.append(" : "); 
  	if(hasIncr()) {
	    getIncr().toString(s);
	  	s.append(" : "); 
	}
    getLimit().toString(s);
  	s.append(""); 
  }

  public void ParExpr.toString(StringBuffer s) {
  	boolean isNeeded = 
  		!(     (getExpr() instanceof ParExpr) 
  			|| (getExpr() instanceof Literal) 
  			|| (getExpr() instanceof Unary) 
  			|| (getExpr() instanceof Binary));
  			
    if(isNeeded) s.append("(");
    getExpr().toString(s);
    if(isNeeded) s.append(")");
  }

  // ID  
  
  public void IdUse.toString(StringBuffer s) {
  	s.append(getID()); 
  }

  public void ParseName.toString(StringBuffer s) {
  	s.append(getID()); 
  }

  // Literals
  
  public void StringLiteral.toString(StringBuffer s) {
    s.append("\"" + escape(getValue()) + "\"");
  }
  
  public void DoubleLiteral.toString(StringBuffer s) {
    s.append(getValue().getText());
  }
  
  public void IntegerLiteral.toString(StringBuffer s) {
    s.append(getValue().getText());
  }

  protected static String Literal.escape(String s) {
    StringBuffer result = new StringBuffer();
    for (int i=0; i < s.length(); i++) {
      switch(s.charAt(i)) {
        case '\b' : result.append("\\b"); break;
        case '\t' : result.append("\\t"); break;
        case '\n' : result.append("\\n"); break;
        case '\f' : result.append("\\f"); break;
        case '\r' : result.append("\\r"); break;
        case '\"' : result.append("\\\""); break;
        case '\'' : result.append("\\\'"); break;
        case '\\' : result.append("\\\\"); break;
        default:
          int value = (int)s.charAt(i);
          if(value < 0x20 || (value > 0x7e))
            result.append(asEscape(value));
          else
            result.append(s.charAt(i));
      }
    }
    return result.toString();
  }
  protected static String Literal.asEscape(int value) {
    StringBuffer s = new StringBuffer("\\u");
    String hex = Integer.toHexString(value);
    for(int i = 0; i < 4-hex.length(); i++)
      s.append("0");
    s.append(hex);
    return s.toString();
  }

  // Unary expression
  
  public void Unary.toString(StringBuffer s) {
    s.append("(");
    s.append(printPreOp());
    getOperand().toString(s);
    s.append(printPostOp());
    s.append(")");
  }

  syn String Unary.printPostOp() = "";

  syn String Unary.printPreOp() = "";
  eq MinusExpr.printPreOp() = "-";
  eq PlusExpr.printPreOp() = "+";
  eq LogNotExpr.printPreOp() = "~";
  
  eq TransposeExpr.printPreOp() = "' ";
  eq ArrayTransposeExpr.printPreOp() = ".' ";
 
  // Binary Expr

  public void Binary.toString(StringBuffer s) {
    s.append("(");
    getLeftOperand().toString(s);
    s.append(printOp());
    getRightOperand().toString(s);
    s.append(")");
  }

  syn String Binary.printOp();
  eq MulExpr.printOp() = " * ";
  eq DivExpr.printOp() = " / ";
  eq LeftDivExpr.printOp() = " \\ ";
  eq PowExpr.printOp() = " ^ ";
  eq AddExpr.printOp() = " + ";
  eq SubExpr.printOp() = " - ";
  
  eq EMulExpr.printOp() = " .* ";
  eq EDivExpr.printOp() = " ./ ";
  eq ELeftDivExpr.printOp() = " .\\ ";
  eq EPowExpr.printOp() = " .^ ";

  eq AndLogicalExpr.printOp() = " & ";
  eq OrLogicalExpr.printOp() = " | ";
  eq ShortCircuitAndExpr.printOp() = " && ";
  eq ShortCircuitOrExpr.printOp() = " || ";
  eq LTExpr.printOp() = " < ";
  eq GTExpr.printOp() = " > ";
  eq LEExpr.printOp() = " <= ";
  eq GEExpr.printOp() = " >= ";
  eq EQExpr.printOp() = " == ";
  eq NEExpr.printOp() = " ~= ";

  public void MethodAccess.toString(StringBuffer s) {
    s.append(getID());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }
  public void MatrixAccess.toString(StringBuffer s) {
    s.append(getID());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }
  public void MatrixDecl.toString(StringBuffer s) {
    s.append("[");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append("; ");
        getArg(i).toString(s);
      }
    }
    s.append("]");
  }

  public void MatrixRow.toString(StringBuffer s) {
    s.append("[");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append("]");
  }

  // for MATLAB -JL
  public void CommentStmt.toString(StringBuffer s) {
    s.append(getstr());
    s.append("\n");
  }

  public void EmptyStmt.toString(StringBuffer s) {
    s.append("\n");
  }

  public void ExprStmt.toString(StringBuffer s) {
    getExpr().toString(s);
    s.append(";\n");
  }

  public void Colon.toString(StringBuffer s) {
    s.append(":");
  }

  // dump the AST to standard output

  public String ASTNode.dumpTree() {
    StringBuffer s = new StringBuffer();
    dumpTree(s, 0);
    return s.toString();
  }

  public void ASTNode.dumpTree(StringBuffer s, int j) {
    for(int i = 0; i < j; i++) {
      s.append("  ");
    }
    s.append(dumpString() + "\n");
    for(int i = 0; i < getNumChild(); i++) {
      if (getChild(i)!=null)
      	getChild(i).dumpTree(s, j + 1);
    }
  }

  public String ASTNode.dumpTreeNoRewrite() {
    StringBuffer s = new StringBuffer();
    dumpTreeNoRewrite(s, 0);
    return s.toString();
  }
  protected void ASTNode.dumpTreeNoRewrite(StringBuffer s, int indent) {
    for(int i = 0; i < indent; i++)
      s.append("  ");
    s.append(dumpString());
    s.append("\n");
    for(int i = 0; i < getNumChildNoTransform(); i++) {
      getChildNoTransform(i).dumpTreeNoRewrite(s, indent+1);
    }
  }

  syn String ASTNode.dumpString() = getClass().getName() + " [" + toString() + "]";
  eq IntegerLiteral.dumpString() = getClass().getName() + " [" + getValue() + "]";
  eq DoubleLiteral.dumpString() = getClass().getName() + " [" + getValue() + "]";
  eq StringLiteral.dumpString() = getClass().getName() + " [" + getValue() + "]";
  eq ParseName.dumpString() = getClass().getName() + " [" + getID() + "]";
  eq MethodAccess.dumpString() = getClass().getName() + " [" + getID() + "]";
  eq MatrixAccess.dumpString() = getClass().getName() + " [" + getID() + "]";

  public String Program.dumpTree() {
    StringBuffer s = new StringBuffer();
    for(Iterator iter = getStmts().iterator(); iter.hasNext(); ) {
      Stmt stmt = (Stmt)iter.next();
        s.append(stmt.dumpTree());
    }
    return s.toString();
  }
  
}
