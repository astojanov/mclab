%import "array.ast.*";

%package "array";

%class "ArrayParser";

%embed {:
    //TODO-AC: factor out common code

    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }

    //// AST helpers ///////////////////////////////////////////////////////////

    //add all elements of a util list to an ast list
    private static <T extends ASTNode<?>> array.ast.List<T> addAll(array.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    //make a new ast list for a given util list
    private static <T extends ASTNode<?>> array.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new array.ast.List<T>(), children);
    }

    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> List<T> nullToEmpty(List<T> original) {
        return original == null ? new List<T>() : original;
    }
:};

%terminals IDENTIFIER, NUMBER, STRING;
%terminals LPAREN, RPAREN, LSQUARE, RSQUARE, LCURLY, RCURLY;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR;
%terminals DOT, COLON, AT;
%terminals COMMA, SEMICOLON, LINE_TERMINATOR;
%terminals COMMENT, HELP_COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT, BRACKET_HELP_COMMENT;
%terminals OTHER_WHITESPACE;

// Precedence and associativity.
//NB: everything seems to be left associative in matlab (even pow and ldiv)
%left MPOW, EPOW;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND;
%left OR;
%left SHORTAND;
%left SHORTOR;

%goal array;

array =
     IDENTIFIER
  |  NUMBER
  |  STRING
  |  LPAREN
  |  RPAREN
  |  LSQUARE
  |  RSQUARE
  |  LCURLY
  |  RCURLY
  |  PLUS
  |  MINUS
  |  MTIMES
  |  ETIMES
  |  MDIV
  |  EDIV
  |  MLDIV
  |  ELDIV
  |  MPOW
  |  EPOW
  |  MTRANSPOSE
  |  ARRAYTRANSPOSE
  |  LE
  |  GE
  |  LT
  |  GT
  |  EQ
  |  NE
  |  AND
  |  OR
  |  NOT
  |  SHORTAND
  |  SHORTOR
  |  DOT
  |  COLON
  |  AT
  |  COMMA
  |  SEMICOLON
  |  LINE_TERMINATOR
  |  COMMENT
  |  HELP_COMMENT
  |  ELLIPSIS_COMMENT
  |  BRACKET_COMMENT
  |  BRACKET_HELP_COMMENT
  |  OTHER_WHITESPACE
  ;