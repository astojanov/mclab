%import "array.ast.*";

%package "array";

%class "ArrayParser";

%embed {:
    //TODO-AC: factor out common code

    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }

    //// AST helpers ///////////////////////////////////////////////////////////

    //add all elements of a util list to an ast list
    private static <T extends ASTNode<?>> array.ast.List<T> addAll(array.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    //make a new ast list for a given util list
    private static <T extends ASTNode<?>> array.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new array.ast.List<T>(), children);
    }

    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> List<T> nullToEmpty(List<T> original) {
        return original == null ? new List<T>() : original;
    }
    
    private static <T extends ASTNode> List<T> maybeAppend(List<T> list, Opt<T> opt) {
        if(opt.getNumChild() == 0) {
            return list;
        } else {
            return list.add(opt.getChild(0));
        }
    }
:};

%terminals IDENTIFIER, NUMBER, STRING;
%terminals LPAREN, RPAREN, LSQUARE, RSQUARE, LCURLY, RCURLY;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR;
%terminals DOT, COLON, AT;
%terminals COMMA, SEMICOLON, LINE_TERMINATOR;
%terminals COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT;
%terminals OTHER_WHITESPACE;

// Precedence and associativity.
//NB: everything seems to be left associative in matlab (even pow and ldiv)
%left MPOW, EPOW;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND;
%left OR;
%left SHORTAND;
%left SHORTOR;

%typeof array = "Array";

%typeof expr, logic_expr, binary_expr, colon_expr, prefix_expr, postfix_expr, pow_expr, primary_expr = "Expr";
%typeof arg_list = "List<Arg>";
%typeof arg = "Arg";
%typeof matrix = "MatrixExpr";
%typeof cell_array = "CellArrayExpr";
%typeof row_list, optional_row_list = "List<Row>";
%typeof row = "Row";
%typeof literal = "LiteralExpr";
%typeof name = "Name";
%typeof access, cell_access, var_access = "LValueExpr";

%typeof param_list = "List<Param>";
%typeof nbfs = "List<Comment>";
%typeof nbf = "Opt<Comment>";

%typeof IDENTIFIER, COMMENT, STRING, NUMBER = "String";

// Precedence and associativity.
//NB: everything seems to be left associative in matlab (even pow and ldiv)
%left MPOW, EPOW;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND;
%left OR;
%left SHORTAND;
%left SHORTOR;

%goal array;

array =
     matrix.m {: return new Matrix(m); :}
  |  cell_array.c {: return new CellArray(c); :}
  |  other_terminal {: return null; :}
  ;

//Non-empty, comma-separated list of parameters (note: no trailing comma)
//shared by input and output parameters
param_list =
     param.p {: return new List<Param>().add(p); :}
  |  param_list.l COMMA param.p {: return l.add(p); :}
  ;

param =
     nbfs.f1 IDENTIFIER.id nbfs.f2 {: return new Param(f1, id, f2); :}
  ;

name =
     IDENTIFIER.id {: return new Name(id); :}
  ;

//precedence from: http://www.mathworks.com/access/helpdesk/help/techdoc/matlab_prog/f0-40063.html
expr =
     logic_expr.l
  |  AT nbfs.f1 LPAREN nbfs.f2 RPAREN nbfs.f3 expr.body {: return new LambdaExpr(f1, new EmptyParamList(f2), f3, body); :}
  |  AT nbfs.f1 LPAREN param_list.l RPAREN nbfs.f3 expr.body {: return new LambdaExpr(f1, new NonEmptyParamList(l), f2, body); :}
  ;

logic_expr =
     colon_expr.e
  |  logic_expr.e1 nbfs.f1 LT nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.LT, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 GT nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.GT, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 LE nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.LE, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 GE nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.GE, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 EQ nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.EQ, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 NE nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.NE, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 AND nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.AND, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 OR nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.OR, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 SHORTAND nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.SHORTAND, f2, e2); :}
  |  logic_expr.e1 nbfs.f1 SHORTOR nbfs.f2 logic_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.SHORTOR, f2, e2); :}
  ;

colon_expr =
     binary_expr.e
  |  binary_expr.e1 nbfs.f1 COLON nbfs.f2 binary_expr.e3 {: return new RangeExpr(e1, f1, f2, new Opt(), new List<Comment>(), new List<Comment>(), e3); :}
  |  binary_expr.e1 nbfs.f1 COLON nbfs.f2 binary_expr.e2 nbfs.f3 COLON nbfs.f4 binary_expr.e3 {: return new RangeExpr(e1, f1, f2, new Opt(e2), f3, f4, e3); :}
  ;

binary_expr =
     prefix_expr.e
  |  binary_expr.e1 nbfs.f1 MTIMES nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.MTIMES, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 ETIMES nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.ETIMES, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 MDIV nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.MDIV, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 EDIV nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.EDIV, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 MLDIV nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.MLDIV, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 ELDIV nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.ELDIV, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 PLUS nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.PLUS, f2, e2); :}
  |  binary_expr.e1 nbfs.f1 MINUS nbfs.f2 binary_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.MINUS, f2, e2); :}
  ;

prefix_expr =
     pow_expr.e
  |  NOT nbfs.f prefix_expr.e {: return new PrefixExpr(Terminals.NOT, f, e); :}
  |  PLUS nbfs.f prefix_expr.e {: return new PrefixExpr(Terminals.PLUS, f, e); :}
  |  MINUS nbfs.f prefix_expr.e {: return new PrefixExpr(Terminals.MINUS, f, e); :}
  ;

pow_expr =
     postfix_expr.e
  |  pow_expr.e1 nbfs.f1 MPOW nbfs.f2 pow_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.MPOW, f2, e2); :}
  |  pow_expr.e1 nbfs.f1 EPOW nbfs.f2 pow_expr.e2 {: return new BinaryExpr(e1, f1, Terminals.EPOW, f2, e2); :}
  ;

postfix_expr =
     primary_expr.e
  |  postfix_expr.e nbfs.f ARRAYTRANSPOSE {: return new PostfixExpr(Terminals.ARRAYTRANSPOSE, f, e); :}
  |  postfix_expr.e nbfs.f MTRANSPOSE {: return new PostfixExpr(Terminals.MTRANSPOSE, f, e); :}
  ;

primary_expr =
     literal.l
  |  LPAREN nbfs.f1 expr.e nbfs.f2 RPAREN {: return new ParenExpr(f1, e, f2); :}
  |  matrix.m
  |  cell_array.c
  |  access.a
  |  AT nbfs.f name.name {: return new FunctionHandleExpr(f, name); :} //TODO-AC: allow qualified name?
  ;

access =
     cell_access.c
  |  cell_access.c nbfs.f1 LPAREN nbfs.f2 RPAREN {: return new ParameterizedExpr(c, f1, new EmptyArgList(f2)); :}
  |  cell_access.c nbfs.f1 LPAREN arg_list.l RPAREN {: return new ParameterizedExpr(c, f1, new NonEmptyArgList(l)); :}
  ;

cell_access =
     var_access.v
  |  cell_access.v nbfs.f LCURLY arg_list.l RCURLY {: return new CellIndexExpr(v, f, l); :}
  ;

var_access =
     name.n {: return new NameExpr(n); :}
  |  var_access.v nbfs.f1 DOT nbfs.f2 name.n {: return new DotExpr(v, f1, f2, n); :}
  ;

literal =
     NUMBER.n {: return new LiteralExpr(n); :}
  |  STRING.s {: return new LiteralExpr(s); :}
  ;

matrix =
     LSQUARE nbfs.f optional_row_list.l RSQUARE {: return new MatrixExpr(f, l); :}
  ;

cell_array =
     LCURLY nbfs.f optional_row_list.l RCURLY {: return new CellArrayExpr(f, l); :}
  ;

optional_row_list =
     {: return new List<Row>(); :}
  |  row_separator {: return new List<Row>(); :}
  |  row_list.l {: return l; :}
  |  row_list.l row_separator {: return l; :}
  ;

row_list =
     row.r {: return new List<Row>().add(r); :}
  |  row_list.l row_separator row.r {: return l.add(r); :}
  ;

row =
     COMMA {: return new Row(new EmptyArgList(new List<Comment>())); :} //TODO-AC: arg_list.l COMMA?
  ;

row_separator =
     LINE_TERMINATOR
  |  SEMICOLON
  ;

arg_list =
     arg.a {: return new List<Arg>().add(a); :}
  |  arg_list.l COMMA arg.a {: return l.add(a); :}
  ;
  
arg =
     nbfs.f1 expr.e nbfs.f2 {: return new Arg(f1, e, f2); :}
  |  nbfs.f1 COLON.c nbfs.f2 {: return new Arg(f1, new ColonExpr(), f2); :}
  ;

//TODO-AC
////non-breaking fillers (zero or more)
//nbfs =
//     {: return new List<Comment>(); :}
//  |  nbfs1.fs
//  ;

//non-breaking fillers (one or more)
nbfs =
     nbf.f {: return maybeAppend(new List<Comment>(), f); :}
  |  nbfs.fs nbf.f {: return maybeAppend(fs, f); :}
  ;

//non-breaking filler
nbf =
     OTHER_WHITESPACE {: return new Opt<Comment>(); :}
  |  ELLIPSIS_COMMENT.c {: return new Opt<Comment>(new Comment(c)); :}
  ;

//terminals that we have to refer to in the grammar (so that beaver doesn't get rid of them)
//but which aren't used in other productions
other_terminal =
  |  COMMENT
  |  BRACKET_COMMENT
  ;
