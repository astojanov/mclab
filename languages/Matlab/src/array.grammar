%import "matlab.ast.*";

%package "matlab";

%class "ArrayParser";

%embed {:
    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }

    //// AST helpers ///////////////////////////////////////////////////////////

    //add all elements of a util list to an ast list
    private static <T extends ASTNode<?>> matlab.ast.List<T> addAll(matlab.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    //make a new ast list for a given util list
    private static <T extends ASTNode<?>> matlab.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new matlab.ast.List<T>(), children);
    }

    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> List<T> nullToEmpty(List<T> original) {
        return original == null ? new List<T>() : original;
    }
:};

%terminals IDENTIFIER;
%terminals NUMBER;
%terminals COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT;
%terminals LPAREN, RPAREN, LSQUARE, RSQUARE, LCURLY, RCURLY;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR;
%terminals DOT, COMMA, SEMICOLON, LINE_TERMINATOR;
%terminals COLON, AT;
%terminals STRING;

// Precedence and associativity.
//NB: everything seems to be left associative in matlab (even pow and ldiv)
%left MPOW, EPOW;
%left MTIMES, MDIV, MLDIV, ETIMES, EDIV, ELDIV;
%left PLUS, MINUS;
%left LT, GT, LE, GE;
%left EQ, NE;
%left AND;
%left OR;
%left SHORTAND;
%left SHORTOR;

%goal array;

//everything
array =
     matrix
  |  cell_array
  |  COMMENT
  |  ELLIPSIS_COMMENT
  |  BRACKET_COMMENT
  ;

//input parameter list for a function
input_params =
     LPAREN RPAREN
  |  LPAREN param_list RPAREN
  ;

//Non-empty, comma-separated list of parameters (note: no trailing comma)
//shared by input and output parameters
param_list =
     IDENTIFIER
  |  param_list COMMA IDENTIFIER
  ;

name =
     IDENTIFIER
  ;

//precedence from: http://www.mathworks.com/access/helpdesk/help/techdoc/matlab_prog/f0-40063.html
expr =
     logic_expr
  |  AT input_params expr
  ;

logic_expr =
     colon_expr
  |  logic_expr LT logic_expr
  |  logic_expr GT logic_expr
  |  logic_expr LE logic_expr
  |  logic_expr GE logic_expr
  |  logic_expr EQ logic_expr
  |  logic_expr NE logic_expr
  |  logic_expr AND logic_expr
  |  logic_expr OR logic_expr
  |  logic_expr SHORTAND logic_expr
  |  logic_expr SHORTOR logic_expr
  ;

colon_expr =
     binary_expr
  |  binary_expr COLON binary_expr
  |  binary_expr COLON binary_expr COLON binary_expr
  ;

binary_expr =
     prefix_expr
  |  binary_expr MTIMES binary_expr
  |  binary_expr ETIMES binary_expr
  |  binary_expr MDIV binary_expr
  |  binary_expr EDIV binary_expr
  |  binary_expr MLDIV binary_expr
  |  binary_expr ELDIV binary_expr
  |  binary_expr PLUS binary_expr
  |  binary_expr MINUS binary_expr
  ;

prefix_expr =
     pow_expr
  |  NOT prefix_expr
  |  PLUS prefix_expr
  |  MINUS prefix_expr
  ;

pow_expr =
     postfix_expr
  |  pow_expr MPOW pow_expr
  |  pow_expr EPOW pow_expr
  ;

postfix_expr =
     primary_expr
  |  postfix_expr ARRAYTRANSPOSE
  |  postfix_expr MTRANSPOSE
  ;

primary_expr =
     literal
  |  LPAREN expr RPAREN
  |  matrix
  |  cell_array
  |  access
  |  AT name
  |  name AT name input_params?
  ;

access =
     cell_access
  |  cell_access LPAREN RPAREN
  |  cell_access LPAREN arg_list RPAREN
  ;

cell_access =
     var_access
  |  cell_access LCURLY arg_list RCURLY
  ;

var_access =
     name
  |  var_access DOT name
  ;

literal =
     NUMBER
  |  STRING
  ;

matrix =
     LSQUARE optional_row_list RSQUARE
  ;

cell_array =
     LCURLY optional_row_list RCURLY
  ;

optional_row_list =
     
  |  row_separator
  |  row_list
  |  row_list row_separator
  ;

row_list =
     row
  |  row_list row_separator row
  ;

row =
     arg_list COMMA?
  ;

row_separator =
     LINE_TERMINATOR
  |  SEMICOLON
  ;

arg_list =
     arg
  |  arg_list COMMA arg
  ;
  
arg =
     expr
  |  COLON
  ;
