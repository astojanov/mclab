//TODO-AC: factor out common bits

%package "matlab";

%class "ExtractionParser";

%embed {:
    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line + 1, e.column + 1) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }
:};

%terminals IDENTIFIER;
%terminals NUMBER;
%terminals COMMENT, HELP_COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT, BRACKET_HELP_COMMENT, SHELL_COMMAND;
%terminals BREAK, CASE, CATCH, CLASSDEF, CONTINUE, ELSE, ELSEIF, END, FOR, FUNCTION, GLOBAL, IF, OTHERWISE, PARFOR, PERSISTENT, RETURN, SWITCH, TRY, WHILE;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR, ASSIGN;
%terminals DOT, COMMA, SEMICOLON, LINE_TERMINATOR;
%terminals COLON, AT;
%terminals STRING;
%terminals METHODS;
%terminals PROPERTIES_BLOCK, EVENTS_BLOCK;
%terminals OTHER_WHITESPACE;
%terminals PARENTHESIZED, MATRIX, CELL_ARRAY;
%terminals MISC;

%typeof IDENTIFIER, NUMBER, STRING = "String";
%typeof COMMENT, BRACKET_COMMENT, HELP_COMMENT, BRACKET_HELP_COMMENT, ELLIPSIS_COMMENT = "String";
%typeof OTHER_WHITESPACE, LINE_TERMINATOR = "String";
%typeof PARENTHESIZED, MATRIX, CELL_ARRAY = "String";
%typeof MISC = "String";

%goal program;

//everything
program = 
     script.s
  |  function_list.f
  |  class_def.c
  |  
  ;

//script file: list of help comments followed by list of stmts
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
script =
     //NB: can't use a stmt_list here - it causes a bunch of warnings (not sure why)
     nbfs stmt.stmts+ last_stmt.s
  |  nbfs last_stmt.s
  |  help_comment.comments+ nbfs stmt.stmts+ last_stmt.s
  |  help_comment.comments+ nbfs last_stmt.s
  |  help_comment.comments+ last_help_comment.c
  |  last_help_comment.c
  ;

//function file: list of functions, separated by whitespace
//NB: no leading whitespace allowed
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
function_list =
     function.functions+
  ;

//function followed by whitespace - only used by function_list (otherwise use function_body)
function =
     function_body.f function_separator*
  ;

function_separator =
     LINE_TERMINATOR
  |  OTHER_WHITESPACE
  |  ELLIPSIS_COMMENT
  |  COMMENT LINE_TERMINATOR
  |  BRACKET_COMMENT LINE_TERMINATOR
  ;

//a function with nothing following the final END
function_body =
     //output params
     FUNCTION nbfs output_params ASSIGN nbfs IDENTIFIER.name nbfs stmt_separator_no_nbf help_comment_list stmt_or_function.body* END
  |  FUNCTION nbfs output_params ASSIGN nbfs IDENTIFIER.name nbfs input_params.in nbfs stmt_separator_no_nbf help_comment_list stmt_or_function.body* END
     //no output params
  |  FUNCTION nbfs IDENTIFIER.name nbfs stmt_separator_no_nbf help_comment_list stmt_or_function.body* END
  |  FUNCTION nbfs IDENTIFIER.name nbfs input_params.in nbfs stmt_separator_no_nbf help_comment_list stmt_or_function.body* END
  ;

//input parameter list for a function
input_params =
     PARENTHESIZED
  ;

//output parameter list for a function
output_params =
     MATRIX nbfs
  |  IDENTIFIER.p nbfs
  ;

//used to mix stmts and nested functions in a containing function
stmt_or_function =
     stmt.s
  |  function_body.f nbfs
  ;

//a classdef file
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
class_def =
     CLASSDEF nbfs attributes.attr nbfs IDENTIFIER.name nbfs stmt_separator_no_nbf help_comment_list class_body* END 
  |  CLASSDEF nbfs attributes.attr nbfs IDENTIFIER.name nbfs LT nbfs superclass_list.superclasses stmt_separator_no_nbf help_comment_list class_body* END
  |  CLASSDEF nbfs IDENTIFIER.name nbfs stmt_separator_no_nbf help_comment_list class_body* END 
  |  CLASSDEF nbfs IDENTIFIER.name nbfs LT nbfs superclass_list.superclasses stmt_separator_no_nbf help_comment_list class_body* END
  ;

attributes =
     PARENTHESIZED
  ;

superclass_list =
     IDENTIFIER.name
  |  superclass_list.l nbfs AND nbfs IDENTIFIER.name
  ;

class_body =
     PROPERTIES_BLOCK nbfs stmt_separator*
  |  EVENTS_BLOCK nbfs stmt_separator*
  |  methods_block nbfs stmt_separator*
  ;

methods_block =
     METHODS nbfs stmt_separator+ methods_body.body* END
  |  METHODS nbfs attributes.attr nbfs stmt_separator+ methods_body.body* END
  ;

methods_body =
     function
  |  function_signature stmt_separator+
  ;
  
function_signature =
     IDENTIFIER.name nbfs
  |  IDENTIFIER.name nbfs input_params.in nbfs
  |  output_params ASSIGN nbfs IDENTIFIER.name nbfs
  |  output_params ASSIGN nbfs IDENTIFIER.name nbfs input_params.in nbfs
  ;

//usually help comments are followed by a newline, but the last one could be followed by EOF instead
last_help_comment =
     help_comment.c
  |  nbfs help_comment_body.c
  ;

help_comment_list =
     nbfs
  |  help_comment+ nbfs
  ;

//help comment with a newline
//NB: should be preceded by whitespace, not nbf, but we'll cheat since Natlab does the real checking
help_comment =
     nbfs help_comment_body.c LINE_TERMINATOR
  ;

//help comment without a newline
help_comment_body =
     HELP_COMMENT.c
  |  BRACKET_HELP_COMMENT.c
  ;

//list of statements (each followed by a separator)
//may be empty
stmt_list =
     stmt.stmts*
  ;

//usually stmts are followed by separators, but the last one could be followed by EOF instead
last_stmt =
     stmt_body
  |  stmt
  ;

//stmt followed by separator
stmt =
     stmt_body stmt_separator
  |  stmt_separator
  ;

//stmt not followed by a separator
stmt_body =
     IDENTIFIER command_arg*
  |  expr_not_starting_with_id
  |  expr_not_starting_with_id ASSIGN nbfs expr_not_starting_with_id
  |  GLOBAL name.names+ nbfs
  |  PERSISTENT name.names+ nbfs
  |  SHELL_COMMAND.c nbfs
  |  TRY nbfs stmt_separator stmt_list.tl END nbfs
  |  TRY nbfs stmt_separator stmt_list.tl CATCH nbfs stmt_separator stmt_list.cl END nbfs
  |  switch_statement nbfs
  |  if_statement nbfs
  |  BREAK nbfs
  |  CONTINUE nbfs
  |  RETURN nbfs
  |  WHILE nbfs expr.e stmt_separator stmt_list.l END nbfs
  |  FOR nbfs for_assign.a stmt_separator stmt_list.l END nbfs
  |  PARFOR nbfs for_assign.a stmt_separator stmt_list.l END nbfs
  ;

command_arg =
     IDENTIFIER
  |  NUMBER
  |  SHELL_COMMAND
  |  BREAK
  |  CASE
  |  CATCH
  |  CLASSDEF
  |  CONTINUE
  |  ELSE
  |  ELSEIF
  |  END
  |  FOR
  |  FUNCTION
  |  GLOBAL
  |  IF
  |  OTHERWISE
  |  PARFOR
  |  PERSISTENT
  |  RETURN
  |  SWITCH
  |  TRY
  |  WHILE
  |  PLUS
  |  MINUS
  |  MTIMES
  |  ETIMES
  |  MDIV
  |  EDIV
  |  MLDIV
  |  ELDIV
  |  MPOW
  |  EPOW
  |  MTRANSPOSE
  |  ARRAYTRANSPOSE
  |  LE
  |  GE
  |  LT
  |  GT
  |  EQ
  |  NE
  |  AND
  |  OR
  |  NOT
  |  SHORTAND
  |  SHORTOR
  |  ASSIGN
  |  DOT
  |  COLON
  |  AT
  |  STRING
  |  METHODS
  |  PROPERTIES_BLOCK
  |  EVENTS_BLOCK
  |  OTHER_WHITESPACE
  |  PARENTHESIZED
  |  MATRIX
  |  CELL_ARRAY
  |  MISC

//NB: NOT these
//  |  COMMENT
//  |  HELP_COMMENT
//  |  ELLIPSIS_COMMENT
//  |  BRACKET_COMMENT
//  |  BRACKET_HELP_COMMENT
//  |  COMMA
//  |  SEMICOLON
//  |  LINE_TERMINATOR
  ;

name =
     nbfs IDENTIFIER
  ;

switch_statement = 
     SWITCH nbfs expr stmt_separator END
  |  SWITCH nbfs expr stmt_separator default_case.d END
  |  SWITCH nbfs expr stmt_separator switch_case.s+ END
  |  SWITCH nbfs expr stmt_separator switch_case.s+ default_case.d END
  ;

switch_case = 
     CASE nbfs expr stmt_separator stmt_list.l
  ;
default_case = 
     OTHERWISE nbfs stmt_separator stmt_list.l 
  ;
  
if_statement = 
     IF nbfs expr stmt_separator stmt_list.l END
  |  IF nbfs expr stmt_separator stmt_list.l else_clause.els END
  |  IF nbfs expr stmt_separator stmt_list.l else_if_clause.elseif+ else_clause.els? END
  ;

else_if_clause = 
     ELSEIF nbfs expr stmt_separator stmt_list.l
  ;
  
else_clause = 
     ELSE nbfs stmt_separator stmt_list.l
  ;

stmt_separator =
      stmt_separator_no_nbf nbfs
  ;

stmt_separator_no_nbf =
     LINE_TERMINATOR
  |  SEMICOLON
  |  COMMA
  |  COMMENT LINE_TERMINATOR
  |  BRACKET_COMMENT LINE_TERMINATOR
  ;

//assignment appearing in a for loop (i.e. optionally surrounded by parens)
for_assign =
     IDENTIFIER.lhs nbfs ASSIGN nbfs expr
  |  PARENTHESIZED nbfs
  ;

expr =
     expr_token expr_token_or_nbf*
  ;

expr_not_starting_with_id =
     expr_token_not_id expr_token_or_nbf*
  ;

expr_token_or_nbf =
     expr_token
  |  nbf
  ;

expr_token =
     expr_token_not_id
  |  IDENTIFIER
  ;

expr_token_not_id =
     LT
  |  GT
  |  LE
  |  GE
  |  EQ
  |  NE
  |  AND
  |  OR
  |  SHORTAND
  |  SHORTOR
  |  COLON
  |  MTIMES
  |  ETIMES
  |  MDIV
  |  EDIV
  |  MLDIV
  |  ELDIV
  |  PLUS
  |  MINUS
  |  NOT
  |  MPOW
  |  EPOW
  |  ARRAYTRANSPOSE
  |  MTRANSPOSE
  |  AT
  |  DOT
  |  NUMBER
  |  STRING
  |  PARENTHESIZED
  |  MATRIX
  |  CELL_ARRAY
  ;

nbf =
     OTHER_WHITESPACE
  |  ELLIPSIS_COMMENT
  ;

nbfs =   | nbf+;