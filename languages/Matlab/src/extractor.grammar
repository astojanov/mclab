//TODO-AC: factor out common bits

%import "matlab.ast.*";

%package "matlab";

%class "ExtractionParser";

%embed {:
    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<matlab.ArrayTranslationProblem> errors = new java.util.ArrayList<matlab.ArrayTranslationProblem>();

    public java.util.List<matlab.ArrayTranslationProblem> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static matlab.ArrayTranslationProblem makeProblem(Symbol token, String msg) {
        return makeProblem(token.getLine(token.getStart()), token.getColumn(token.getStart()), msg);
    }

    //given a position, return a canonical string representation
    private static matlab.ArrayTranslationProblem makeProblem(int line, int col, String msg) {
        return new matlab.ArrayTranslationProblem(line, col, msg);
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(makeProblem(token, "unexpected token " + Terminals.NAMES[token.getId()]));
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(makeProblem(e.line + 1, e.column + 1, "scanner error: " + e.getMessage()));
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(makeProblem(token, "try deleting " + Terminals.NAMES[token.getId()]));
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(makeProblem(token, "try inserting " + Terminals.NAMES[token.getId()]));
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(makeProblem(token, "try replacing with " + Terminals.NAMES[token.getId()]));
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }
    
    //// AST helpers ///////////////////////////////////////////////////////////

    //add all elements of a util list to an ast list
    private static <T extends ASTNode<?>> matlab.ast.List<T> addAll(matlab.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    //make a new ast list for a given util list
    private static <T extends ASTNode<?>> matlab.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new matlab.ast.List<T>(), children);
    }

    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> List<T> nullToEmpty(List<T> original) {
        return original == null ? new List<T>() : original;
    }
    
    private static <T extends ASTNode> List<T> maybeAppend(List<T> list, Opt<T> opt) {
        if(opt.getNumChild() == 0) {
            return list;
        } else {
            return list.add(opt.getChild(0));
        }
    }
:};

%terminals IDENTIFIER;
%terminals NUMBER;
%terminals COMMENT, ELLIPSIS_COMMENT, BRACKET_COMMENT, SHELL_COMMAND;
%terminals BREAK, CASE, CATCH, CLASSDEF, CONTINUE, ELSE, ELSEIF, END, FOR, FUNCTION, GLOBAL, IF, OTHERWISE, PARFOR, PERSISTENT, RETURN, SWITCH, TRY, WHILE;
%terminals PLUS, MINUS, MTIMES, ETIMES, MDIV, EDIV, MLDIV, ELDIV, MPOW, EPOW, MTRANSPOSE, ARRAYTRANSPOSE, LE, GE, LT, GT, EQ, NE, AND, OR, NOT, SHORTAND, SHORTOR, ASSIGN;
%terminals DOT, COMMA, SEMICOLON, LINE_TERMINATOR;
%terminals COLON, AT;
%terminals STRING;
%terminals METHODS;
%terminals PROPERTIES_BLOCK, EVENTS_BLOCK;
%terminals OTHER_WHITESPACE;
%terminals PARENTHESIZED, MATRIX, CELL_ARRAY;
%terminals MISC;

%typeof program = "Program";
%typeof script, function_list, class_def, empty_program = "ListNode";

%goal program;

//everything
program = 
     script.l {: return new Program(l); :}
  |  function_list.l {: return new Program(l); :}
  |  class_def.l {: return new Program(l); :}
  |  empty_program.l {: return new Program(l); :}
  ;

empty_program =
     nbf.s1* {: return new ListNode().add(s1); :}
  ;

//script file: list of help comments followed by list of stmts
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
script =
     //NB: can't use a stmt_list here - it causes a bunch of warnings (not sure why)
     stmt.s1+ last_stmt.s2
        {: return new ListNode().add(s1).add(s2); :}
  |  nbf.s1+ stmt.s2+ last_stmt.s3
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  |  last_stmt.s1
        {: return new ListNode().add(s1); :}
  |  nbf.s1+ last_stmt.s2
        {: return new ListNode().add(s1).add(s2); :}
  ;

//function file: list of functions, separated by whitespace
//NB: no leading whitespace allowed
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
function_list =
     function.s1+ {: return new ListNode().add(s1); :}
  ;

//function followed by whitespace - only used by function_list (otherwise use function_body)
function =
     function_body.s1 function_separator.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

function_separator =
     LINE_TERMINATOR
  |  OTHER_WHITESPACE
  |  ELLIPSIS_COMMENT
  |  COMMENT //in practice, the next token will be either LINE_TERMINATOR or EOF
  |  BRACKET_COMMENT //in practice, the next token will be either LINE_TERMINATOR or EOF
  ;

//a function with nothing following the final END
function_body =
     FUNCTION.s1 nbf.s2* output_params.s3 ASSIGN.s4 nbf.s5* IDENTIFIER.s6 nbf.s7* stmt_separator.s8 stmt_or_function.s9* END.s10
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10); :}
  |  FUNCTION.s1 nbf.s2* output_params.s3 ASSIGN.s4 nbf.s5* IDENTIFIER.s6 nbf.s7* input_params.s8 nbf.s9* stmt_separator.s10 stmt_or_function.s11* END.s12
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10).add(s11).add(s12); :}
  |  FUNCTION.s1 nbf.s2* IDENTIFIER.s3 nbf.s4* stmt_separator.s5 stmt_or_function.s6* END.s7
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  |  FUNCTION.s1 nbf.s2* IDENTIFIER.s3 nbf.s4* input_params.s5 nbf.s6* stmt_separator.s7 stmt_or_function.s8* END.s9
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9); :}
  ;

//input parameter list for a function
input_params =
     PARENTHESIZED
  ;

//output parameter list for a function
output_params =
     MATRIX.s1 nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  |  IDENTIFIER.s1 nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

//used to mix stmts and nested functions in a containing function
stmt_or_function =
     stmt
  |  function_body.s1 nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

//a classdef file
//NB: must be non-empty to avoid conflicting with EmptyProgram case above
class_def =
     CLASSDEF.s1 nbf.s2* attributes.s3 nbf.s4* IDENTIFIER.s5 nbf.s6* stmt_separator_no_nbf.s7 help_comment_list.s8 class_body.s9* END.s10 trailing_filler.s11*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10).add(s11); :} 
  |  CLASSDEF.s1 nbf.s2* attributes.s3 nbf.s4* IDENTIFIER.s5 nbf.s6* LT.s7 nbf.s8* superclass_list.s9 stmt_separator_no_nbf.s10 help_comment_list.s11 class_body.s12* END.s13 trailing_filler.s14*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10).add(s11).add(s12).add(s13).add(s14); :}
  |  CLASSDEF.s1 nbf.s2* IDENTIFIER.s3 nbf.s4* stmt_separator_no_nbf.s5 help_comment_list.s6 class_body.s7* END.s8 trailing_filler.s9*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9); :} 
  |  CLASSDEF.s1 nbf.s2* IDENTIFIER.s3 nbf.s4* LT.s5 nbf.s6* superclass_list.s7 stmt_separator_no_nbf.s8 help_comment_list.s9 class_body.s10* END.s11 trailing_filler.s12*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10).add(s11).add(s12); :}
  ;

trailing_filler = 
     LINE_TERMINATOR
  |  OTHER_WHITESPACE
  |  ELLIPSIS_COMMENT
  |  COMMENT
  |  BRACKET_COMMENT
  ;

attributes =
     PARENTHESIZED
  ;

superclass_list =
     IDENTIFIER
  |  superclass_list.s1 nbf.s2* AND.s3 nbf.s4* IDENTIFIER.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  ;

class_body =
     PROPERTIES_BLOCK.s1 nbf.s2* stmt_separator.s3*
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  |  EVENTS_BLOCK.s1 nbf.s2* stmt_separator.s3*
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  |  methods_block.s1 nbf.s2* stmt_separator.s3*
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  ;

methods_block =
     METHODS.s1 nbf.s2* stmt_separator.s3+ methods_body.s4* END.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  |  METHODS.s1 nbf.s2* attributes.s3 nbf.s4* stmt_separator.s5+ methods_body.s6* END.s7
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  ;

methods_body =
     function
  |  function_signature.s1 stmt_separator.s2+ {: return new ListNode().add(s1).add(s2); :}
  ;
  
function_signature =
     IDENTIFIER.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  IDENTIFIER.s1 nbf.s2* input_params.s3 nbf.s4*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4); :}
  |  output_params.s1 ASSIGN.s2 nbf.s3* IDENTIFIER.s4 nbf.s5*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  |  output_params.s1 ASSIGN.s2 nbf.s3* IDENTIFIER.s4 nbf.s5* input_params.s6 nbf.s7*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  ;

help_comment_list =
     nbf*
  |  help_comment.s1+ nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

//help comment with a newline
//NB: should be preceded by whitespace, not nbf, but we'll cheat since Natlab does the real checking
help_comment =
     nbf.s1* help_comment_body.s2 LINE_TERMINATOR.s3 {: return new ListNode().add(s1).add(s2).add(s3); :}
  ;

//help comment without a newline
help_comment_body =
     COMMENT
  |  BRACKET_COMMENT
  ;

//list of statements (each followed by a separator)
//may be empty
stmt_list =
     stmt*
  ;

//usually stmts are followed by separators, but the last one could be followed by EOF instead
last_stmt =
     stmt_body
  |  stmt
  |  COMMENT
  |  BRACKET_COMMENT
  ;

//stmt followed by separator
stmt =
     stmt_body.s1 stmt_separator.s2 {: return new ListNode().add(s1).add(s2); :}
  |  stmt_separator
  ;

//stmt not followed by a separator
stmt_body =
     IDENTIFIER.cmd command_arg.args*
        {:
            if(args == null || args.value == null) {
                //no args => simple function call or variable expr
                return cmd;
            }
            ArrayList<beaver.Symbol> argSyms = new ArrayList<beaver.Symbol>();
            for(Object o : (ArrayList) args.value) {
                argSyms.add((beaver.Symbol) ((beaver.Symbol) o).value);
            }
            return new MaybeCmdExtract(cmd, argSyms);
        :}
  |  expr_not_starting_with_id
  |  expr_not_starting_with_id.s1 ASSIGN.s2 nbf.s3* expr_not_starting_with_id.s4
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4); :}
  |  GLOBAL.s1 name.s2+ nbf.s3*
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  |  PERSISTENT.s1 name.s2+ nbf.s3*
        {: return new ListNode().add(s1).add(s2).add(s3); :}
  |  SHELL_COMMAND.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  TRY.s1 nbf.s2* stmt_separator.s3 stmt_list.s4 END.s5 nbf.s6*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6); :}
  |  TRY.s1 nbf.s2* stmt_separator.s3 stmt_list.s4 CATCH.s5 nbf.s6* stmt_separator.s7 stmt_list.s8 END.s9 nbf.s10*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8).add(s9).add(s10); :}
  |  switch_statement.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  if_statement.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  BREAK.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  CONTINUE.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  RETURN.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  |  WHILE.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5 END.s6 nbf.s7*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  |  FOR.s1 nbf.s2* for_assign.s3 stmt_separator.s4 stmt_list.s5 END.s6 nbf.s7*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  |  PARFOR.s1 nbf.s2* for_assign.s3 stmt_separator.s4 stmt_list.s5 END.s6 nbf.s7*
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  ;

//Wrap each symbol in antoher symbol so that when beaver mangles the IDs, the original symbols are still recoverable
command_arg =
  //expr tokens (NB: not just delegating because returns may be different)
     IDENTIFIER.s {: return new Symbol(s); :}
  |  LT.s {: return new beaver.Symbol(s); :}
  |  GT.s {: return new beaver.Symbol(s); :}
  |  LE.s {: return new beaver.Symbol(s); :}
  |  GE.s {: return new beaver.Symbol(s); :}
  |  EQ.s {: return new beaver.Symbol(s); :}
  |  NE.s {: return new beaver.Symbol(s); :}
  |  AND.s {: return new beaver.Symbol(s); :}
  |  OR.s {: return new beaver.Symbol(s); :}
  |  SHORTAND.s {: return new beaver.Symbol(s); :}
  |  SHORTOR.s {: return new beaver.Symbol(s); :}
  |  COLON.s {: return new beaver.Symbol(s); :}
  |  MTIMES.s {: return new beaver.Symbol(s); :}
  |  ETIMES.s {: return new beaver.Symbol(s); :}
  |  MDIV.s {: return new beaver.Symbol(s); :}
  |  EDIV.s {: return new beaver.Symbol(s); :}
  |  MLDIV.s {: return new beaver.Symbol(s); :}
  |  ELDIV.s {: return new beaver.Symbol(s); :}
  |  PLUS.s {: return new beaver.Symbol(s); :}
  |  MINUS.s {: return new beaver.Symbol(s); :}
  |  NOT.s {: return new beaver.Symbol(s); :}
  |  MPOW.s {: return new beaver.Symbol(s); :}
  |  EPOW.s {: return new beaver.Symbol(s); :}
  |  ARRAYTRANSPOSE.s {: return new beaver.Symbol(s); :}
  |  MTRANSPOSE.s {: return new beaver.Symbol(s); :}
  |  AT.s {: return new beaver.Symbol(s); :}
  |  DOT.s {: return new beaver.Symbol(s); :}
  |  NUMBER.s {: return new beaver.Symbol(s); :}
  |  STRING.s {: return new beaver.Symbol(s); :}
  |  PARENTHESIZED.s {: return new beaver.Symbol(s); :}
  |  MATRIX.s {: return new beaver.Symbol(s); :}
  |  CELL_ARRAY.s {: return new beaver.Symbol(s); :}
  //other tokens
  |  SHELL_COMMAND.s {: return new beaver.Symbol(s); :}
  |  BREAK.s {: return new beaver.Symbol(s); :}
  |  CASE.s {: return new beaver.Symbol(s); :}
  |  CATCH.s {: return new beaver.Symbol(s); :}
  |  CLASSDEF.s {: return new beaver.Symbol(s); :}
  |  CONTINUE.s {: return new beaver.Symbol(s); :}
  |  ELSE.s {: return new beaver.Symbol(s); :}
  |  ELSEIF.s {: return new beaver.Symbol(s); :}
  |  END.s {: return new beaver.Symbol(s); :}
  |  FOR.s {: return new beaver.Symbol(s); :}
  |  FUNCTION.s {: return new beaver.Symbol(s); :}
  |  GLOBAL.s {: return new beaver.Symbol(s); :}
  |  IF.s {: return new beaver.Symbol(s); :}
  |  OTHERWISE.s {: return new beaver.Symbol(s); :}
  |  PARFOR.s {: return new beaver.Symbol(s); :}
  |  PERSISTENT.s {: return new beaver.Symbol(s); :}
  |  RETURN.s {: return new beaver.Symbol(s); :}
  |  SWITCH.s {: return new beaver.Symbol(s); :}
  |  TRY.s {: return new beaver.Symbol(s); :}
  |  WHILE.s {: return new beaver.Symbol(s); :}
  |  ASSIGN.s {: return new beaver.Symbol(s); :}
  |  METHODS.s {: return new beaver.Symbol(s); :}
  |  PROPERTIES_BLOCK.s {: return new beaver.Symbol(s); :}
  |  EVENTS_BLOCK.s {: return new beaver.Symbol(s); :}
  |  OTHER_WHITESPACE.s {: return new beaver.Symbol(s); :}
  |  ELLIPSIS_COMMENT.s {: return new beaver.Symbol(s); :}
  |  MISC.s {: return new beaver.Symbol(s); :}

//NB: NOT these
//  |  COMMENT
//  |  HELP_COMMENT
//  |  BRACKET_COMMENT
//  |  BRACKET_HELP_COMMENT
//  |  COMMA
//  |  SEMICOLON
//  |  LINE_TERMINATOR
  ;

name =
     nbf.s1* IDENTIFIER.s2  {: return new ListNode().add(s1).add(s2); :}
  ;

switch_statement = 
     SWITCH.s1 nbf.s2* expr.s3 stmt_separator.s4 END.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  |  SWITCH.s1 nbf.s2* expr.s3 stmt_separator.s4 default_case.s5 END.s6
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6); :}
  |  SWITCH.s1 nbf.s2* expr.s3 stmt_separator.s4 switch_case.s5+ END.s6
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6); :}
  |  SWITCH.s1 nbf.s2* expr.s3 stmt_separator.s4 switch_case.s5+ default_case.s6 END.s7
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  ;

switch_case = 
     CASE.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  ;
default_case = 
     OTHERWISE.s1 nbf.s2* stmt_separator.s3 stmt_list.s4
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4); :}
  ;
  
if_statement = 
     IF.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5 END.s6
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6); :}
  |  IF.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5 else_clause.s6 END.s7
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7); :}
  |  IF.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5 else_if_clause.s6+ else_clause.s7? END.s8
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5).add(s6).add(s7).add(s8); :}
  ;

else_if_clause = 
     ELSEIF.s1 nbf.s2* expr.s3 stmt_separator.s4 stmt_list.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  ;
  
else_clause = 
     ELSE.s1 nbf.s2* stmt_separator.s3 stmt_list.s4 
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4); :}
  ;

stmt_separator =
      stmt_separator_no_nbf.s1 nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

stmt_separator_no_nbf =
     LINE_TERMINATOR
  |  SEMICOLON
  |  COMMA
  |  COMMENT.s1 LINE_TERMINATOR.s2 {: return new ListNode().add(s1).add(s2); :}
  |  BRACKET_COMMENT.s1 LINE_TERMINATOR.s2 {: return new ListNode().add(s1).add(s2); :}
  ;

//assignment appearing in a for loop (i.e. optionally surrounded by parens)
for_assign =
     IDENTIFIER.s1 nbf.s2* ASSIGN.s3 nbf.s4* expr.s5
        {: return new ListNode().add(s1).add(s2).add(s3).add(s4).add(s5); :}
  |  PARENTHESIZED.s1 nbf.s2*
        {: return new ListNode().add(s1).add(s2); :}
  ;

expr =
     expr_token.s1 expr_token_or_nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

expr_not_starting_with_id =
     expr_token_not_id.s1 expr_token_or_nbf.s2* {: return new ListNode().add(s1).add(s2); :}
  ;

expr_token_or_nbf =
     expr_token
  |  nbf
  ;

expr_token =
     expr_token_not_id
  |  IDENTIFIER
  ;

expr_token_not_id =
     LT
  |  GT
  |  LE
  |  GE
  |  EQ
  |  NE
  |  AND
  |  OR
  |  SHORTAND
  |  SHORTOR
  |  COLON
  |  MTIMES
  |  ETIMES
  |  MDIV
  |  EDIV
  |  MLDIV
  |  ELDIV
  |  PLUS
  |  MINUS
  |  NOT
  |  MPOW
  |  EPOW
  |  ARRAYTRANSPOSE
  |  MTRANSPOSE
  |  AT
  |  DOT
  |  NUMBER
  |  STRING
  |  PARENTHESIZED
  |  MATRIX.m {: return new MatrixExtract(m); :}
  |  CELL_ARRAY.c {: return new CellArrayExtract(c); :}
  ;

nbf =
     OTHER_WHITESPACE
  |  ELLIPSIS_COMMENT
  ;
