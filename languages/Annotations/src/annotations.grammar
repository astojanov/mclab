//Inspired by the Diamondback Ruby annotation system

%import "annotations.ast.*";

%package "annotations";

%class "AnnotationParser";

%embed {:
    //// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line, e.column) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }
    
    //// AST helpers ///////////////////////////////////////////////////////////

    //add all elements of a util list to an ast list
    private static <T extends ASTNode<?>> annotations.ast.List<T> addAll(annotations.ast.List<T> node, java.util.List<T> children) {
        for(T child : children) {
            node.add(child);
        }
        return node;
    }

    //make a new ast list for a given util list
    private static <T extends ASTNode<?>> annotations.ast.List<T> makeListNode(java.util.List<T> children) {
        if(children == null) {
            return null;
        }
        return addAll(new annotations.ast.List<T>(), children);
    }

    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> annotations.ast.List<T> nullToEmpty(annotations.ast.List<T> original) {
        return original == null ? new annotations.ast.List<T>() : original;
    }
:};

%terminals NUMBER, IDENTIFIER;
%terminals DOT, STMT_TERMINATOR, ELEMENT_SEPARATOR, SIZE_OF, EQ, HAS_TYPE;
%terminals LPAREN, RPAREN, LCURLY, RCURLY, LSQUARE, RSQUARE;
%terminals VARARG_MODIFIER, HANDLE_MODIFIER, TYPE_VAR_MODIFIER, UNKNOWN_TYPE, ARROW;
%terminals UNION, INTERSECT;

%typeof NUMBER = "Integer";
%typeof IDENTIFIER = "String";

%typeof annotation = "Annotation";
%typeof stmt, stmt_body = "Stmt";
%typeof entity = "Entity";
%typeof type_stmt_body = "TypeStmt";
%typeof type = "Type";
%typeof list_or_arrow_type = "Type";
%typeof union_type = "UnionType";
%typeof union_op_type = "Type";
%typeof intersection_type = "IntersectionType";
%typeof intersection_op_type = "Type";
%typeof arrow_type = "ArrowType";
%typeof arg_list_type = "Type";
%typeof result_type = "Type";
%typeof unit_type = "UnitType";
%typeof vararg_type = "VarArgType";
%typeof list_type = "Type";
%typeof list_type_list = "List<Type>";
%typeof cell_array_type = "CellArrayType";
%typeof tuple_type = "TupleType";
%typeof matrix_type = "Type";
%typeof base_type = "BaseType";
%typeof struct_type = "StructType";
%typeof field_entry = "FieldEntry";
%typeof field_entry_list = "List<FieldEntry>";
%typeof size_stmt_body = "SizeStmt";
%typeof size = "Size";

%goal annotation;

annotation =
     stmt.l* {: return new Annotation(nullToEmpty(makeListNode(_list_l))); :}
  ;

stmt =
     stmt_body.s STMT_TERMINATOR
  ;

stmt_body =
     type_stmt_body
  |  size_stmt_body
  ;

entity =
     IDENTIFIER.i {: return new Variable(i); :}
  |  entity.e LCURLY num_list.l RCURLY {: return new Cell(e, (java.util.List<Integer>) l.value); :}
  |  entity.e DOT IDENTIFIER.i {: return new Field(e, i); :}
  ;

type_stmt_body =
     entity.e HAS_TYPE type.t {: return new TypeStmt(e, t); :}
  ;

type =
     list_or_arrow_type
  |  intersection_type
  ;

list_or_arrow_type =
     list_type
  |  arrow_type
  ;

intersection_type =
     intersection_op_type.t1 INTERSECT intersection_op_type.t2 {: return new IntersectionType(new List<Type>().add(t1).add(t2)); :}
  |  intersection_type.i INTERSECT intersection_op_type.t {: i.getTypes().add(t); return i; :}
  ;

intersection_op_type =
     list_or_arrow_type
  ;

arrow_type =
     arg_list_type.a ARROW result_type.t {: return new ArrowType(a, t); :}
  ;

arg_list_type =
     result_type
  |  LPAREN list_type_list.l ELEMENT_SEPARATOR vararg_type.t RPAREN {: return new ArgTupleType(l, t); :}
  ;

result_type =
     list_type
  |  vararg_type
  |  unit_type
  ;

vararg_type =
     list_type.t VARARG_MODIFIER {: return new VarArgType(t); :}
  ;

unit_type =
     LPAREN RPAREN {: return new UnitType(); :}
  ;

list_type =
     base_type
  |  tuple_type
  |  cell_array_type
  |  union_type
  |  matrix_type
  ;

list_type_list =
     list_type.t {: return new List<Type>().add(t); :}
  |  list_type_list.l ELEMENT_SEPARATOR list_type.t {: return l.add(t); :}
  ;

tuple_type =
  |  LPAREN list_type_list.l ELEMENT_SEPARATOR list_type.t RPAREN {: return new TupleType(l.add(t)); :}
  ;

cell_array_type =
     LCURLY list_type.t RCURLY {: return new CellArrayType(t); :}
  ;

union_type =
     union_op_type.t1 UNION union_op_type.t2 {: return new UnionType(new List<Type>().add(t1).add(t2)); :}
  |  union_type.u UNION union_op_type.t {: u.getTypes().add(t); return u; :}
  ;

union_op_type =
     base_type
  |  tuple_type
  |  cell_array_type
  |  matrix_type
  |  LPAREN intersection_type.t RPAREN
  |  LPAREN arrow_type.t RPAREN
  ;

matrix_type =
     LSQUARE base_type.b RSQUARE {: return new MatrixType(b); :}
  ;

base_type =
     IDENTIFIER.i {: return new PrimitiveType(i); :}
  |  TYPE_VAR_MODIFIER IDENTIFIER.i {: return new TypeVarType(i); :}
  |  HANDLE_MODIFIER LPAREN arrow_type.a RPAREN {: return new HandleType(a); :}
  |  UNKNOWN_TYPE {: return new UnknownType(); :}
  |  struct_type
  ;

struct_type =
     LCURLY field_entry_list.l RCURLY {: return new StructType(l); :}
  ;

field_entry =
     IDENTIFIER.i HAS_TYPE type.t {: return new FieldEntry(i, t); :}
  ;

field_entry_list =
     field_entry.e {: return new List<FieldEntry>().add(e); :}
  |  field_entry_list.l ELEMENT_SEPARATOR field_entry.e {: return l.add(e); :}
  ;

size_stmt_body =
     SIZE_OF entity.e EQ size.s {: return new SizeStmt(e, s); :}
  ;

size =
     LSQUARE num_list.l RSQUARE {: return new Size((java.util.List<Integer>) l.value); :}
  ;

num_list =
     NUMBER.n {: java.util.List<Integer> nums = new java.util.ArrayList<Integer>(); nums.add(n); return new Symbol(nums); :}
  |  num_list.l ELEMENT_SEPARATOR NUMBER.n {: ((java.util.List<Integer>) l.value).add(n); return l; :}
  ;