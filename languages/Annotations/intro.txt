The Annotations language is a type-annotation language for Matlab.  It draws inspiration from the type annotations of Diamondback Ruby.

Four types of statements are available:

#x = [2, 3, 1]; //x has size [2, 3, 1]
x : T; //x has type T
+x; //x is definitely a scalar
-x; //x is definitely not a scalar

The following entities may appear on the LHS:

identifier (e.g. x)
entity.identifier (e.g. x.y)
entity{indices} (e.g. x{1})

The following types are available:

Arrow Types:
  ArgType -> ResultType
  If there are multiple arguments, then parens are required (e.g. (a, b) -> c).
  The last (or only) argument may be a vararg, indicated with a * (e.g. x* -> y).
  The result type may be a vararg.
  ArgType or ResultType may be void (i.e. ()).

Intersection types:
  t1 & t2
  May be required for overloading.

Union types:
  t1 | t2
  Must be parenthesized if confusion would arise.
  Not strictly necessary.

Matrix Types:
  [t]
  All elements have the same type.

Cell Array Types:
  {t}
  Unless otherwise specified, all element have the same type.

Tuple Types:
  (t1, t2, t3)
  Might be useful for arrays of fixed size that are always used in the same way.
  Not strictly necessary.

Named Type:
  int
  Not validated.

Type Variables:
  $a
  Useful for polymorphism (e.g. id : $a -> $a).

Handle Types:
  @(t1 -> t2)
  Argument must be an arrow type.

Unknown Type:
  ?
  To indicate that no info is available.
  Somewhat redundant, given type variables.

The various types are somewhat nestable but we have tried to restrict such nesting to reasonable cases.  If you find some additional form of nesting desirable, please feel free to contact us.

Clearly, the definitive reference is the grammar itself: annotations.grammar.